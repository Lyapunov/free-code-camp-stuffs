<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.24/browser.min.js"></script>

<!-- 
  CSS 
-->
<link rel="stylesheet" type="text/css" href="basic.css">

<!-- 
  JS 
-->
<script type="text/babel">
         var SPECIAL_COLORS = {WOODBROWN:"#966F33",IRON:"#434b4d",STEEL:"#4682B4",POISON:"#00FF00",TABLEBROWN:"#835C3B",CHAIRBROWN:"#8B4513",DARKGRAY0:"#282828",DARKGRAY1:"#484848",DARKGRAY2:"#585858"};

         var currentTarget = 0;

         var ATTRIBUTES_BAREFIST       = {name:"nothing", value: 0, size:0};
         var ATTRIBUTES_WOODEN_STICK   = {name:"wooden stick"  ,color:SPECIAL_COLORS.WOODBROWN,width:30,height:4,value:1,holder:"weapon"};
         var ATTRIBUTES_IRON_BAR       = {name:"iron bar"      ,color:SPECIAL_COLORS.IRON     ,width:30,height:4,value:2,holder:"weapon"};
         var ATTRIBUTES_STEEL_SWORD    = {name:"steel sword"   ,color:SPECIAL_COLORS.STEEL    ,width:30,height:4,value:3,holder:"weapon"};
         var ATTRIBUTES_SILVER_SWORD   = {name:"silver sword"  ,color:'silver'                ,width:30,height:4,value:4,holder:"weapon"};
         var ATTRIBUTES_GOLD_SWORD     = {name:"gold sword"    ,color:'gold'                  ,width:30,height:4,value:5,holder:"weapon"};
         var ATTRIBUTES_CRISTAL_SWORD  = {name:"cristal sword" ,color:'cyan'                  ,width:30,height:4,value:6,holder:"weapon"};

         var ATTRIBUTES_MINISHIELD     = {name:"minishield"    ,color:"black",width:11,height:12,value:1,size:0.75,holder:"shield"}
         var ATTRIBUTES_BUCKLER_SHIELD = {name:"buckler"       ,color:"black",width:15,height:12,value:2,size:1.00,holder:"shield"}
         var ATTRIBUTES_BATTLESHIELD   = {name:"battleshield"  ,color:"black",width:19,height:12,value:3,size:1.25,holder:"shield"}
         var ATTRIBUTES_KITE_SHIELD    = {name:"kite shield"   ,color:"black",width:24,height:12,value:4,size:1.50,holder:"shield"}
         var ATTRIBUTES_TOWER_SHIELD   = {name:"tower shield"  ,color:"black",width:30,height:12,value:5,size:2.00,holder:"shield"}

class CacheIndexerBuckets {
   getIndexKey(ps) {
      return Math.floor(ps[0])*this.keyMaxRowSize+Math.floor(ps[1]);
   }

   getBucketIndex(pos) {
      return "x" + (Math.floor(pos[0] / this.bucketGridSize)*this.bucketMaxRowSize+Math.floor(pos[1] / this.bucketGridSize)).toString();
   }

   iterateOverBucketItemsAroundPos(pos, func1, func2) {
      this.iterateOverBucketItemsAroundPosInternal(pos, this.buckets, func1, func2)
   }

   iterateOverBucketItemsAroundPosInternal(pos, sbuckets, func1, func2) {
      var distr = {};
      for ( var y = -1; y <= 1; ++y ) {
         for ( var x = -1; x <= 1; ++x ) {
            var psel = this.getBucketIndex([(this.bucketGridSize-1)*y+pos[0],(this.bucketGridSize-1)*x+pos[1]]);
            if ( !(psel in distr) && (psel in sbuckets) ) {
               distr[psel] = 1;
               var bucket = sbuckets[psel];
               if ( func1 ) {
                  for ( var j = 0; j < bucket.length; ++j ) {
                     func1(bucket[j]);
                  }
               }
               if ( func2 ) {
                  func2(sbuckets, psel);
                  delete sbuckets[psel];
               }
            }
         }
      }
   }

   generateBuckets(objs) {
      for ( var i = 0; i < objs.length; ++i ) {
         var psel = this.getBucketIndex(objs[i][0]);
         if ( !(psel in this.buckets) ) {
            this.buckets[psel] = [];
         }
         this.buckets[psel].push(i);
      }
   }

   partiallyRegenerateBuckets(pos,objs) {
      var affectedBuckets = {};
      this.iterateOverBucketItemsAroundPosInternal(pos,
                                                   this.buckets,
                                                   undefined,
                                                   (buckets,psel)=>{affectedBuckets[psel]=buckets[psel];});

      this.iterateOverBucketItemsAroundPosInternal(pos,
                                                   affectedBuckets,
                                                   (i)=>{ var psel = this.getBucketIndex(objs[i][0]);
                                                          (this.buckets[psel] = this.buckets[psel] || []).push(i); });
   }

   cleaner() {
      return (this.buckets = {});
   }

   createIndexFromBuckets(objs,condition,pos) {
      if ( this.buckets == undefined ) {
         this.buckets = this.cleaner();
         this.generateBuckets(objs);
      } else {
         this.partiallyRegenerateBuckets(pos,objs);
      }

      var index = {};
      this.iterateOverBucketItemsAroundPosInternal(pos,
                                                   this.buckets,
                                                   (i)=>{ condition(objs[i]) && ( index[ this.getIndexKey(objs[i][0]) ] = i ) });

      return index;
   }

   constructor() {
      this.buckets = undefined;
      this.bucketGridSize = 15;
      this.bucketMaxRowSize = 10000;
      this.keyMaxRowSize = 10000;
   }
}

class MapGenerator {
   carveRoom(map,world,y,x,yrad,xrad) {
      if ( yrad >= y || xrad >= x || x + xrad >= map[0].length - 1 || y + yrad >= map.length - 1 ) {
         return 0;
      }

      for ( var py = y - yrad - 1; py <= y + yrad + 1; ++py ) {
         for ( var px = x - xrad - 1; px <= x + xrad + 1; ++px ) {
            if ( map[py][px] != 0 ) {
               return 0;
            }
         }
      }

      var area = 0;
      for ( var py = y - yrad; py <= y + yrad; ++py ) {
         for ( var px = x - xrad; px <= x + xrad; ++px ) {
            map[py][px] = world;
            ++area;
         }
      }

      return area;
   }

   getRandomInt(max) {
     return Math.floor(Math.random() * Math.floor(max));
   }

   isInsideRoom(py,px,map,y,x,yrad,xrad) {
      return px >= x-xrad && px <= x+xrad && py >= y-yrad && py <= y+yrad;
   }

   extendRetval(retval, num) {
      for ( var y = 0; y < retval.length; ++y ) {
         for ( var i = 0; i < num; ++i ) {
            retval[y].push(0);
         }
      }
   }

   generateBasicRoomStructure(sizeY,sizeX,world,lshift) {
      var retval = [];
      for ( var y = 0; y < sizeY; ++y ) {
         var row = [];
         for ( var x = 0; x < sizeX+lshift; ++x ) {
            row.push(0);
         }
         retval.push(row);
      }
      var rooms = [];
      rooms.push([2,2+lshift,1,1]);
      var sarea = this.carveRoom(retval,world,...rooms[0]);
      for ( var i = 0; i < 1000; ++i ) {
         var room = [this.getRandomInt(sizeY),this.getRandomInt(sizeX)+lshift,this.getRandomInt(5)+1,this.getRandomInt(5)+1];
         if ( room[1] - lshift <= room[3] ) {
            continue;
         }
         var aarea = this.carveRoom(retval,world,...room);
         if ( aarea ) {
            sarea += aarea;
            rooms.push(room);
         }
      }
      return [retval,rooms,sarea];
   }

   getMapCell(map,y,x) {
      if ( y < 0 || y >= map.length || x < 0 || x >= map[y].length ) {
         return 0;
      }
      return map[y][x];
   }

   bfsMap(map, source, goods) {
      if ( goods.indexOf(this.getMapCell(map, source.y,source.x)) == -1 ) {
         return [];
      }
      var retval = [];
      for ( var y = 0; y < map.length; ++y ) {
         var row = [];
         for ( var x = 0; x < map[y].length; ++x ) {
            row.push(0);
         }
         retval.push(row);
      }
      var hops = {};
      var findings = [[source.y,source.x]];
      hops[findings[0]]=false;
      var level = 1;
      retval[source.y][source.x] = level;
      var dirs = [[0,1],[-1,0],[0,-1],[1,0]];
      while ( findings.length > 0 ) {
         ++level;
         var nfindings = [];
         for ( var i = 0; i < findings.length; ++i ) {
            for ( var j = 0; j < dirs.length; ++j ) {
               var nextp = [(findings[i][0]+dirs[j][1]),(findings[i][1]+dirs[j][0])];
               if ( goods.indexOf(this.getMapCell(map,nextp[0],nextp[1])) >= 0
                 && hops[nextp] === undefined ) {
                  nfindings.push(nextp);
                  hops[nextp] = findings[i];
                  retval[nextp[0]][nextp[1]] = level;
               }
            }
         }
         findings = nfindings;
      }
      return [retval, level];
   }

   countMap(map,low,hi) {
      var retval = 0;
      for ( var y = 0; y < map.length; ++y ) {
         for ( var x = 0; x < map[y].length; ++x ) {
            if ( map[y][x] >= low && map[y][x] < hi ) {
               ++retval;
            }
         }
      }
      return retval;
   }

   getNthCell(map,low,hi,n) {
      var counter = 0;
      for ( var y = 0; y < map.length; ++y ) {
         for ( var x = 0; x < map[y].length; ++x ) {
            if ( map[y][x] >= low && map[y][x] < hi ) {
               if ( counter == n ) {
                  return [y,x];
               }
               ++counter;
            }
         }
      }
      return false;
   }

   generateMap(sizeY,sizeX,world,ept,spt,wpt,createEnemy,createStuff,lshift) {
      var retval = [];
      var rooms = [];
      var sarea = 0;
      if ( !lshift ) {
         lshift = 0;
      }

      for ( var i = 0; i < 10; ++i ) {
         var [nretval, nrooms, nsarea] = this.generateBasicRoomStructure(sizeY,sizeX,world,lshift);
         if ( nsarea > sarea ) {
            retval = nretval;
            rooms = nrooms;
            sarea = nsarea;
         }
      }

      rooms.sort(function (rooma,roomb) {return (rooma[0] > roomb[0] || rooma[0] == roomb[0] && rooma[1] > roomb[1])
                                               -(roomb[0] > rooma[0] || roomb[0] == rooma[0] && roomb[1] > rooma[1]) });
      var throneRoom = rooms.length - 1;

      var tset = [0];
      var tdic = {0:1};
      var oset = [];
      for ( var i = 1; i < rooms.length; ++i ) {
         oset.push(i);
      }
      while ( oset.length > 0 ) {
         var source = tset[this.getRandomInt(tset.length)];
         var target = oset[this.getRandomInt(oset.length)];
         var type = this.getRandomInt(2);
         for ( var ty = Math.min(rooms[source][0],rooms[target][0]); ty <= Math.max(rooms[source][0],rooms[target][0]); ++ty ) {
            var py = ty;
            var px = rooms[type?source:target][1];
            retval[py][px] = world;
            for ( var i = 0; i < rooms.length; ++i ) {
               if ( this.isInsideRoom(py,px,retval,...rooms[i]) && !(tdic[i]) ) {
                  oset = oset.filter(x=>x!=i);
                  tset.push(i);
                  tdic[i] = world;
               }
            }
         }
         for ( var tx = Math.min(rooms[source][1],rooms[target][1]); tx <= Math.max(rooms[source][1],rooms[target][1]); ++tx ) {
            var py = rooms[type?target:source][0];
            var px = tx;
            retval[py][px] = world;
            for ( var i = 0; i < rooms.length; ++i ) {
               if ( this.isInsideRoom(py,px,retval,...rooms[i]) && !(tdic[i]) ) {
                  oset = oset.filter(x=>x!=i);
                  tset.push(i);
                  tdic[i] = world;
               }
            }
         }
      }
      // decorating rooms
      {
         if ( world == 1 ) {
            retval[rooms[0][0]][rooms[0][1]-rooms[0][3]] = 6;
         }

         for ( var i = 1; i < rooms.length; ++i ) {
            if ( i == throneRoom ) {
               continue;
            }
            if ( i % 3 ) {
               if ( rooms[i][2] == 1 && rooms[i][3] == 1 ) {
                  retval[rooms[i][0]][rooms[i][1]] = 6 + world;
               } else if ( rooms[i][2] == 1 && rooms[i][3] >= 2 )  {
                  retval[rooms[i][0]][rooms[i][1]-1] = 6 + world;
                  retval[rooms[i][0]][rooms[i][1]] = 6 + world;
                  retval[rooms[i][0]][rooms[i][1]+1] = 6 + world;
               } else if ( rooms[i][2] >= 2 && rooms[i][3] == 1 )  {
                  retval[rooms[i][0]-1][rooms[i][1]] = 6 + world;
                  retval[rooms[i][0]][rooms[i][1]] = 6 + world;
                  retval[rooms[i][0]+1][rooms[i][1]] = 6 + world;
               } else if ( rooms[i][2] == 2 && rooms[i][3] >= 2 || rooms[i][2] >= 2 && rooms[i][3] == 2 ) {
                  var type = this.getRandomInt(2);
                  retval[rooms[i][0]-1][rooms[i][1]-1] = 12 + world;
                  retval[rooms[i][0]+1][rooms[i][1]-1] = 12 + world;
                  if ( type ) {
                     retval[rooms[i][0]][rooms[i][1]-1] = 6 + world;
                     retval[rooms[i][0]][rooms[i][1]] = 6 + world;
                     retval[rooms[i][0]][rooms[i][1]+1] = 6 + world;
                  } else {
                     retval[rooms[i][0]-1][rooms[i][1]] = 6 + world;
                     retval[rooms[i][0]][rooms[i][1]] = 6 + world;
                     retval[rooms[i][0]+1][rooms[i][1]] = 6 + world;
                  }
               } else {
                  var type = this.getRandomInt(2);
                  if ( type ) {
                     for ( var px = -1; px <= 1; ++px ) {
                        for ( var py = -1; py <= 1; ++py ) {
                           if ( !px && !py || px == 1 && !py ) {
                              continue;
                           }
                           retval[rooms[i][0]+py][rooms[i][1]+px] = 6 + world;
                        }
                     }
                     retval[rooms[i][0]-1][rooms[i][1]-2] = 12 + world;
                     retval[rooms[i][0]][rooms[i][1]-2] = 12 + world;
                     retval[rooms[i][0]+1][rooms[i][1]-2] = 12 + world;
                  } else {
                     retval[rooms[i][0]-1][rooms[i][1]-2] = 6 + world;
                     retval[rooms[i][0]-1][rooms[i][1]]   = 6 + world;
                     retval[rooms[i][0]+1][rooms[i][1]-2] = 12 + world;
                     retval[rooms[i][0]+1][rooms[i][1]] = 12 + world;
                  }
               }
            }
         }

         retval[rooms[throneRoom][0]][rooms[throneRoom][1]] = 17;
         for ( var i = 1; i <= rooms[throneRoom][3]; ++i ) {
            retval[rooms[throneRoom][0]][rooms[throneRoom][1]+i] = 5;
         }
      }

      if ( createStuff !== undefined && createEnemy !== undefined ) {
         var [hmap,hlev] = this.bfsMap(retval,{y:rooms[0][0],x:rooms[0][1]},[world,4,5]);
         var helper = [10,Math.floor(hlev/3),Math.floor(2*hlev/3),hlev-2];
         var numbers= [];
         for ( var i = 0; i < 3; ++i ) {
            numbers.push(this.countMap(hmap,helper[i],helper[i+1]));
         }
         var placedict = {};
         var enemies = [];
         var stuffs  = [];
         for ( var i = 0; i < 3; ++i ) {
            {
               var ecounter = 0;
               var disti = Math.floor((helper[i+1] - helper[i])/3.0);
               var subhelper = [helper[i],helper[i]+disti,helper[i]+2*disti,helper[i+1],helper[i+1]];
               while ( ecounter < ept ) {
                  var rnum = this.getRandomInt(numbers[i]);
                  var order = ecounter % 3;
                  var pos = this.getNthCell(hmap,subhelper[order],subhelper[order+2],rnum);
                  if ( pos && !placedict[pos] ) {
                     placedict[pos] = 1;
                     enemies.push( createEnemy( pos, (i*3+order+9*(world-1)) ) );
                     ++ecounter;
                  }
               }
            }
            {
               var scounter = 0;
               while ( scounter < spt ) {
                  var rnum = this.getRandomInt(numbers[i]);
                  var pos  = this.getNthCell(hmap,helper[i],helper[i+1],rnum);
                  if ( pos && !placedict[pos] ) {
                     placedict[pos] = 1;
                     stuffs.push( createStuff( pos, 0 ) ); // healing potion
                     ++scounter;
                  }
               }
            }

            {
               var scounter = 0;
               while ( scounter < 1 ) {
                  var rnum = this.getRandomInt(numbers[i]);
                  var pos  = this.getNthCell(hmap,helper[i],helper[i+1],rnum);
                  if ( pos && !placedict[pos] ) {
                     placedict[pos] = 1;
                     stuffs.push( createStuff( pos, 1 ) ); // poison gas
                     ++scounter;
                  }
               }
            }
            
            if ( i != 1 ) {
               var scounter = 0;
               while ( scounter < wpt ) {
                  var rnum = this.getRandomInt(numbers[i]);
                  var wlow = helper[i];
                  var wup = helper[i+1];
                  if ( scounter == 0 && i == 0 && world == 1 ) {
                     wup = wlow + Math.floor((wup - wlow)/3);
                  }
                  var pos = this.getNthCell(hmap,wlow,wup,rnum);
                  if ( pos && !placedict[pos] ) {
                     placedict[pos] = 1;
                     stuffs.push( createStuff( pos, 4*world-2+(i>1)*2 ) ); // sword
                     ++scounter;
                  }
               }
            }
            if ( i != 0 ) {
               var scounter = 0;
               while ( scounter < wpt ) {
                  var rnum = this.getRandomInt(numbers[i]);
                  var pos  = this.getNthCell(hmap,helper[i],helper[i+1],rnum);
                  if ( pos && !placedict[pos] ) {
                     placedict[pos] = 1;
                     stuffs.push( createStuff( pos, 4*world-1+(i>1)*2 ) ); // shield
                     ++scounter;
                  }
               }
            }
         }
         this.extendRetval(retval, 3);

         if ( world < 3 ) {
            // river
            var riverColor = 3 + world;
            var [ty,tx] = rooms[throneRoom];
            --tx;
            while ( retval[ty][tx] == world ) {
              --tx;
            }
            ++tx;
            var tx2 = tx-1;
            while ( tx2 > 0 && retval[ty][tx2] == 0 ) {
              --tx2;
            }
            if ( tx2 > 0 ) {
               tx = tx2;
               while ( tx2 > 0 && retval[ty][tx2] != 0 ) {
                 --tx2;
               }
               ++tx2;
               if ( tx2 > 0 ) {
                  tx = tx2;
               }
            }
            retval[ty][tx] = riverColor;
            var s = 0;
            for ( var x = tx; x < retval[ty].length-2; ++x ) {
               retval[ty-s][x] = riverColor;
               retval[ty-s][x+1] = riverColor;
               ++s;
            }
            while (ty-s > 1) {
               retval[ty-s][x] = riverColor;
               ++s;
            }
         }

         if ( world == 3 ) {
            // Diabolito
            var [ty,tx,ry,rx] = rooms[throneRoom];
            var xit = false;
            for ( var y = ty-ry; y <= ty+ry && !xit; ++y ) {
               for ( var x = tx-rx; x <= tx+rx && !xit; ++x ) {
                  var pos = [y,x];
                  if ( !placedict[pos] ) {
                     placedict[pos] = 1;
                     enemies.push( createEnemy( pos, 27 ) );
                     xit = true;
                  }
               }
            }
         }

         return [retval,enemies,stuffs];
      } else {
         return [retval,undefined,undefined];
      }
   }

   mergeMaps(map1,map2) {
      var retval = [];
      for ( var y = 0; y < Math.max(map1.length,map2.length); ++y ) {
         var width1 = ( y < map1.length ? map1[y].length : 0 );
         var width2 = ( y < map2.length ? map2[y].length : 0 );
         var row = [];
         for ( var x = 0; x < Math.max(width1,width2); ++x ) {
            var val1 = this.getMapCell(map1,y,x);
            var val2 = this.getMapCell(map2,y,x);
            row.push((val1 || val2));
         }
         retval.push(row);
      }
      return retval;
   }

   generateThreeInOneMap(sizeY,sizeX,ept,spt,wpt,enemyGenerator,stuffGenerator) {
      var [map1,enemies1,stuffs1] = this.generateMap(sizeY,sizeX,1,ept,spt,wpt,enemyGenerator,stuffGenerator);
      var [map2,enemies2,stuffs2] = this.generateMap(sizeY,sizeX,2,ept,spt,wpt,enemyGenerator,stuffGenerator,sizeX+2);
      var [map3,enemies3,stuffs3] = this.generateMap(sizeY,sizeX,3,ept,spt,wpt,enemyGenerator,stuffGenerator,2*sizeX+4);
      var fullMap = this.mergeMaps(this.mergeMaps(map1,map2),map3);
      fullMap[2][sizeX+2]   = 4;
      fullMap[2][2*sizeX+4] = 5;
      return [fullMap,enemies1.concat(enemies2).concat(enemies3),stuffs1.concat(stuffs2).concat(stuffs3)];
   }

   drawPack(pack) {
      var [map,enemies,stuffs] = pack;
      var retval = "";
      for ( var y = 0; y < map.length; ++y ) {
         var row = "";
         for ( var x = 0; x < map[y].length; ++x ) {
            if ( enemies !== undefined ) {
               var enemyHere = enemies.filter(([pos,code])=>pos[0]==y&&pos[1]==x);
               if ( enemyHere.length ) {
                  var [pos,enemy] = enemyHere[0];
                  row += enemy;

                  continue;
               }
            }
            if ( stuffs !== undefined ) {
               var stuffHere = stuffs.filter(([pos,code])=>pos[0]==y&&pos[1]==x);
               if ( stuffHere.length ) {
                  var [pos,stuff] = stuffHere[0];
                  row += stuff;
                  continue;
               }
            }
            if ( map[y][x] == 0 ) {
               row += "#";
            } else if ( map[y][x] == 5 ) {
               row += "=";
            } else if ( map[y][x] == 4 ) {
               row += "~";
            } else if ( map[y][x] == 17 ) {
               row += "h";
            } else {
               row += " ";
            }
         }
         row += "\n";
         retval += row;
      }
      return retval;
   }
}

class Sounds {
    constructor() {
       this.walkAudio = new Audio( "data:audio/ogg;base64,T2dnUwACAAAAAAAAAAAER3N7AAAAAKnicT0BHgF2b3JiaXMAAAAAAUAfAAAAAAAAsDYAAAAAAACZAU9nZ1MAAAAAAAAAAAAABEdzewEAAACclrl8Czz///////////+1A3ZvcmJpcywAAABYaXBoLk9yZyBsaWJWb3JiaXMgSSAyMDE1MDEwNSAo4puE4puE4puE4puEKQAAAAABBXZvcmJpcxJCQ1YBAAABAAxSFCElGVNKYwiVUlIpBR1jUFtHHWPUOUYhZBBTiEkZpXtPKpVYSsgRUlgpRR1TTFNJlVKWKUUdYxRTSCFT1jFloXMUS4ZJCSVsTa50FkvomWOWMUYdY85aSp1j1jFFHWNSUkmhcxg6ZiVkFDpGxehifDA6laJCKL7H3lLpLYWKW4q91xpT6y2EGEtpwQhhc+211dxKasUYY4wxxsXiUyiC0JBVAAABAABABAFCQ1YBAAoAAMJQDEVRgNCQVQBABgCAABRFcRTHcRxHkiTLAkJDVgEAQAAAAgAAKI7hKJIjSZJkWZZlWZameZaouaov+64u667t6roOhIasBADIAAAYhiGH3knMkFOQSSYpVcw5CKH1DjnlFGTSUsaYYoxRzpBTDDEFMYbQKYUQ1E45pQwiCENInWTOIEs96OBi5zgQGrIiAIgCAACMQYwhxpBzDEoGIXKOScggRM45KZ2UTEoorbSWSQktldYi55yUTkompbQWUsuklNZCKwUAAAQ4AAAEWAiFhqwIAKIAABCDkFJIKcSUYk4xh5RSjinHkFLMOcWYcowx6CBUzDHIHIRIKcUYc0455iBkDCrmHIQMMgEAAAEOAAABFkKhISsCgDgBAIMkaZqlaaJoaZooeqaoqqIoqqrleabpmaaqeqKpqqaquq6pqq5seZ5peqaoqp4pqqqpqq5rqqrriqpqy6ar2rbpqrbsyrJuu7Ks256qyrapurJuqq5tu7Js664s27rkearqmabreqbpuqrr2rLqurLtmabriqor26bryrLryratyrKua6bpuqKr2q6purLtyq5tu7Ks+6br6rbqyrquyrLu27au+7KtC7vourauyq6uq7Ks67It67Zs20LJ81TVM03X9UzTdVXXtW3VdW1bM03XNV1XlkXVdWXVlXVddWVb90zTdU1XlWXTVWVZlWXddmVXl0XXtW1Vln1ddWVfl23d92VZ133TdXVblWXbV2VZ92Vd94VZt33dU1VbN11X103X1X1b131htm3fF11X11XZ1oVVlnXf1n1lmHWdMLqurqu27OuqLOu+ruvGMOu6MKy6bfyurQvDq+vGseu+rty+j2rbvvDqtjG8um4cu7Abv+37xrGpqm2brqvrpivrumzrvm/runGMrqvrqiz7uurKvm/ruvDrvi8Mo+vquirLurDasq/Lui4Mu64bw2rbwu7aunDMsi4Mt+8rx68LQ9W2heHVdaOr28ZvC8PSN3a+AACAAQcAgAATykChISsCgDgBAAYhCBVjECrGIIQQUgohpFQxBiFjDkrGHJQQSkkhlNIqxiBkjknIHJMQSmiplNBKKKWlUEpLoZTWUmotptRaDKG0FEpprZTSWmopttRSbBVjEDLnpGSOSSiltFZKaSlzTErGoKQOQiqlpNJKSa1lzknJoKPSOUippNJSSam1UEproZTWSkqxpdJKba3FGkppLaTSWkmptdRSba21WiPGIGSMQcmck1JKSamU0lrmnJQOOiqZg5JKKamVklKsmJPSQSglg4xKSaW1kkoroZTWSkqxhVJaa63VmFJLNZSSWkmpxVBKa621GlMrNYVQUgultBZKaa21VmtqLbZQQmuhpBZLKjG1FmNtrcUYSmmtpBJbKanFFluNrbVYU0s1lpJibK3V2EotOdZaa0ot1tJSjK21mFtMucVYaw0ltBZKaa2U0lpKrcXWWq2hlNZKKrGVklpsrdXYWow1lNJiKSm1kEpsrbVYW2w1ppZibLHVWFKLMcZYc0u11ZRai621WEsrNcYYa2415VIAAMCAAwBAgAlloNCQlQBAFAAAYAxjjEFoFHLMOSmNUs45JyVzDkIIKWXOQQghpc45CKW01DkHoZSUQikppRRbKCWl1losAACgwAEAIMAGTYnFAQoNWQkARAEAIMYoxRiExiClGIPQGKMUYxAqpRhzDkKlFGPOQcgYc85BKRljzkEnJYQQQimlhBBCKKWUAgAAChwAAAJs0JRYHKDQkBUBQBQAAGAMYgwxhiB0UjopEYRMSielkRJaCylllkqKJcbMWomtxNhICa2F1jJrJcbSYkatxFhiKgAA7MABAOzAQig0ZCUAkAcAQBijFGPOOWcQYsw5CCE0CDHmHIQQKsaccw5CCBVjzjkHIYTOOecghBBC55xzEEIIoYMQQgillNJBCCGEUkrpIIQQQimldBBCCKGUUgoAACpwAAAIsFFkc4KRoEJDVgIAeQAAgDFKOSclpUYpxiCkFFujFGMQUmqtYgxCSq3FWDEGIaXWYuwgpNRajLV2EFJqLcZaQ0qtxVhrziGl1mKsNdfUWoy15tx7ai3GWnPOuQAA3AUHALADG0U2JxgJKjRkJQCQBwBAIKQUY4w5h5RijDHnnENKMcaYc84pxhhzzjnnFGOMOeecc4wx55xzzjnGmHPOOeecc84556CDkDnnnHPQQeicc845CCF0zjnnHIQQCgAAKnAAAAiwUWRzgpGgQkNWAgDhAACAMZRSSimllFJKqKOUUkoppZRSAiGllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimVUkoppZRSSimllFJKKaUAIN8KBwD/BxtnWEk6KxwNLjRkJQAQDgAAGMMYhIw5JyWlhjEIpXROSkklNYxBKKVzElJKKYPQWmqlpNJSShmElGILIZWUWgqltFZrKam1lFIoKcUaS0qppdYy5ySkklpLrbaYOQelpNZaaq3FEEJKsbXWUmuxdVJSSa211lptLaSUWmstxtZibCWlllprqcXWWkyptRZbSy3G1mJLrcXYYosxxhoLAOBucACASLBxhpWks8LR4EJDVgIAIQEABDJKOeecgxBCCCFSijHnoIMQQgghREox5pyDEEIIIYSMMecghBBCCKGUkDHmHIQQQgghhFI65yCEUEoJpZRSSucchBBCCKWUUkoJIYQQQiillFJKKSGEEEoppZRSSiklhBBCKKWUUkoppYQQQiillFJKKaWUEEIopZRSSimllBJCCKGUUkoppZRSQgillFJKKaWUUkooIYRSSimllFJKCSWUUkoppZRSSikhlFJKKaWUUkoppQAAgAMHAIAAI+gko8oibDThwgMQAAAAAgACTACBAYKCUQgChBEIAAAAAAAIAPgAAEgKgIiIaOYMDhASFBYYGhweICIkAAAAAAAAAAAAAAAABE9nZ1MABGwMAAAAAAAABEdzewIAAAAvJcoWDkVCR0k7ODk6PUY/OTkvjhfntxSLIsUAvkvWMq7pu5aVlKh8M6cdc9exWbs/69iOKgiEbB/bON+Er5kRtZRVq9oiIVWC0X+YRmlTMfQS01PxHyYAjhu3H4paJmBwbgrLENRwk9QhETtpxA0WeoZfJzWMB0XUq9Mh/bd1KmFQaZajQUaz09ctLCnw3p6i6LrL2n4ynW0CipySFrVUkS+CALLpje7lkSNFg3Bw3suPf/nxu/hGEQVAECif14UEIhtp5/MXBZ8H3/peHld6oByZR/XteAdFDKS69KeWYQ+uYz5IzaMSN6aVmJ/5rfbjMr9o2sP5HrzZg/Oh2516f9N0zwaQyqX+ZgtP785TcmcN3uzBiUPlgnJR53b3s+43lqShlb2fcSoAgiHSUYAaOio2QSvoWFefN0RVyh6dbdrwyfb05L1uI819GEN8fGThsnruK9q3Okbvd7nAF83XwK93AQCKHkcPRYacxkAf2Kt0zFp2jmDyUw7AcE1QEV0FSvPmtTF0Qr/AdxxN736KvcJb0bImFRHvEdGrAI4d1x8WxlSckHsU6tOH3LkZliZbV3c8AnlSH0fgyZRyoq4jZQcDmAo8l7AeV/Li655rgrmyGqYrAI4dd2+3KCx0gnr3zPl85Ek0zmBFE2FfpheeVnWONEweSOWnIe2+0LnWq5hyg+DIWHcegrFhmtHGHgCKnNY7CiuVY2hRzJJPIEibVYd9w9R7zifeWuvymcyZHUWKXn1VDKieB1aprhRaxibK2cqVNknDbHul5zEApqS4LGrjM/j54tjY3ubTzF6HfewZC344X16f18fLvRdERgIwyMShv5ye58fl4EUSsSSyfTSA3a/qMjdOBP7Y64/NGuUCAIKgbLUAgaRAm5BdneXXq5c6RP3wj8pJgBt9vkw+zO1KTdjuK7Uxm4x3zR8cPTO97m6ocLsVtfkjrwi7hvIkAIody06DQC7DCuW0IX9vLx0a7dSIuTvnOnJzwFXSwuVRHVkjXWyvFalk2x8kk8gs8sxA+u3ZJcydAI4d5xeFRUZjGPnkY0v8jIsV3Exa+BAyjEd+vu7jo5+29xDy2d1bfqqIFAD1Fx6QXR/WZVDnnu03AYoZbwuqQkvBF+COHL0TADiN8QM91km0zPoHe+aEnH5LGZxLqYFu/EBpDDBRfaMA" );
       this.ouchAudio = new Audio( "data:audio/mp3;base64,/+MYxAANCALJsUEQAAaBCEAQYWD4PgQ4CAIQfB8HwfAgIZcEHZR0QAh8QAg6z/xP4nB8EHf/lwfP//5c/EH//ggqw+/8gIth/+MYxAYOwnLsyYc4ANy3//5DYVTzh035f//uWX89tat/0MCr/0NOmGM5ho6aOt/dSiH/6K3+1V/2HC+/kAp4q5XpDPGO31G5/+MYxAYNUUrUAYcQAIYb8eVrP1+jOVx1kqTQxmkUYyOVHFf/CgLGHuY4sf/Bo0OSVOinV/tp06P/ly16qiWv+Yxn/UpS5v///+MYxAsP8MKEUcIYAP9DAQCAlBUFTuDQNHvLHhKCoLA1/1A0DX5UFQVBoO8FQ14NA0+DQNA1lQ15JYKu/4iPYlBWYr///////+MYxAYJMAWcEAAEAP/FhXFRQWf5kFhcVxUW//5UVFg9i/4sLC4qKkXcKkJMQU1FMy45OS41qqqqqqqqqqqqqqqqqqqqqqqq" );
       this.pickupAudio = new Audio( "data:audio/ogg;base64,T2dnUwACAAAAAAAAAADYxeALAAAAAGlgz24BHgF2b3JiaXMAAAAAAUSsAAAAAAAAgLsAAAAAAAC4AU9nZ1MAAAAAAAAAAAAA2MXgCwEAAADQuk5/Dzz/////////////////MgN2b3JiaXMsAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAxNTAxMDUgKOKbhOKbhOKbhOKbhCkAAAAAAQV2b3JiaXMfQkNWAQAAAQAYY1QpRplS0kqJGXOUMUaZYpJKiaWEFkJInXMUU6k515xrrLm1IIQQGlNQKQWZUo5SaRljkCkFmVIQS0kldBI6J51jEFtJwdaYa4tBthyEDZpSTCnElFKKQggZU4wpxZRSSkIHJXQOOuYcU45KKEG4nHOrtZaWY4updJJK5yRkTEJIKYWSSgelU05CSDWW1lIpHXNSUmpB6CCEEEK2IIQNgtCQVQAAAQDAQBAasgoAUAAAEIqhGIoChIasAgAyAAAEoCiO4iiOIzmSY0kWEBqyCgAAAgAQAADAcBRJkRTJsSRL0ixL00RRVX3VNlVV9nVd13Vd13UgNGQVAAABAEBIp5mlGiDCDGQYCA1ZBQAgAAAARijCEANCQ1YBAAABAABiKDmIJrTmfHOOg2Y5aCrF5nRwItXmSW4q5uacc845J5tzxjjnnHOKcmYxaCa05pxzEoNmKWgmtOacc57E5kFrqrTmnHPGOaeDcUYY55xzmrTmQWo21uaccxa0pjlqLsXmnHMi5eZJbS7V5pxzzjnnnHPOOeecc6oXp3NwTjjnnHOi9uZabkIX55xzPhmne3NCOOecc84555xzzjnnnHOC0JBVAAAQAABBGDaGcacgSJ+jgRhFiGnIpAfdo8MkaAxyCqlHo6ORUuoglFTGSSmdIDRkFQAACAAAIYQUUkghhRRSSCGFFFKIIYYYYsgpp5yCCiqppKKKMsoss8wyyyyzzDLrsLPOOuwwxBBDDK20EktNtdVYY62555xrDtJaaa211koppZRSSikIDVkFAIAAABAIGWSQQUYhhRRSiCGmnHLKKaigAkJDVgEAgAAAAgAAADzJc0RHdERHdERHdERHdETHczxHlERJlERJtEzL1ExPFVXVlV1b1mXd9m1hF3bd93Xf93Xj14VhWZZlWZZlWZZlWZZlWZZlWYLQkFUAAAgAAIAQQgghhRRSSCGlGGPMMeegk1BCIDRkFQAACAAgAAAAwFEcxXEkR3IkyZIsSZM0S7M8zdM8TfREURRN01RFV3RF3bRF2ZRN13RN2XRVWbVdWbZt2dZtX5Zt3/d93/d93/d93/d93/d1HQgNWQUASAAA6EiOpEiKpEiO4ziSJAGhIasAABkAAAEAKIqjOI7jSJIkSZakSZ7lWaJmaqZneqqoAqEhqwAAQAAAAQAAAAAAKJriKabiKaLiOaIjSqJlWqKmaq4om7Lruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7rui4QGrIKAJAAANCRHMmRHEmRFEmRHMkBQkNWAQAyAAACAHAMx5AUybEsS9M8zdM8TfRET/RMTxVd0QVCQ1YBAIAAAAIAAAAAADAkw1IsR3M0SZRUS7VUTbVUSxVVT1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTVN0zRNIDRkJQAABADAYo3B5SAhJSXl3hDCEJOeMSYhtV4hBJGS3jEGFYOeMqIMct5C4xCDHggNWREARAEAAMYgxxBzyDlHqZMSOeeodJQa5xyljlJnKcWYYs0oldhSrI1zjlJHraOUYiwtdpRSjanGAgAAAhwAAAIshEJDVgQAUQAAhDFIKaQUYow5p5xDjCnnmHOGMeYcc44556B0UirnnHROSsQYc445p5xzUjonlXNOSiehAACAAAcAgAALodCQFQFAnACAQZI8T/I0UZQ0TxRFU3RdUTRd1/I81fRMU1U90VRVU1Vt2VRVWZY8zzQ901RVzzRV1VRVWTZVVZZFVdVt03V123RV3ZZt2/ddWxZ2UVVt3VRd2zdV1/Zd2fZ9WdZ1Y/I8VfVM03U903Rl1XVtW3VdXfdMU5ZN15Vl03Vt25VlXXdl2fc103Rd01Vl2XRd2XZlV7ddWfZ903WF35VlX1dlWRh2XfeFW9eV5XRd3VdlVzdWWfZ9W9eF4dZ1YZk8T1U903RdzzRdV3VdX1dd19Y105Rl03Vt2VRdWXZl2fddV9Z1zzRl2XRd2zZdV5ZdWfZ9V5Z13XRdX1dlWfhVV/Z1WdeV4dZt4Tdd1/dVWfaFV5Z14dZ1Ybl1XRg+VfV9U3aF4XRl39eF31luXTiW0XV9YZVt4VhlWTl+4ViW3feVZXRdX1ht2RhWWRaGX/id5fZ943h1XRlu3efMuu8Mx++k+8rT1W1jmX3dWWZfd47hGDq/8OOpqq+brisMpywLv+3rxrP7vrKMruv7qiwLvyrbwrHrvvP8vrAso+z6wmrLwrDatjHcvm4sv3Acy2vryjHrvlG2dXxfeArD83R1XXlmXcf2dXTjRzh+ygAAgAEHAIAAE8pAoSErAoA4AQCPJImiZFmiKFmWKIqm6LqiaLqupGmmqWmeaVqaZ5qmaaqyKZquLGmaaVqeZpqap5mmaJqua5qmrIqmKcumasqyaZqy7LqybbuubNuiacqyaZqybJqmLLuyq9uu7Oq6pFmmqXmeaWqeZ5qmasqyaZquq3meanqeaKqeKKqqaqqqraqqLFueZ5qa6KmmJ4qqaqqmrZqqKsumqtqyaaq2bKqqbbuq7Pqybeu6aaqybaqmLZuqatuu7OqyLNu6L2maaWqeZ5qa55mmaZqybJqqK1uep5qeKKqq5ommaqqqLJumqsqW55mqJ4qq6omea5qqKsumatqqaZq2bKqqLZumKsuubfu+68qybqqqbJuqauumasqybMu+78qq7oqmKcumqtqyaaqyLduy78uyrPuiacqyaaqybaqqLsuybRuzbPu6aJqybaqmLZuqKtuyLfu6LNu678qub6uqrOuyLfu67vqucOu6MLyybPuqrPq6K9u6b+sy2/Z9RNOUZVM1bdtUVVl2Zdn2Zdv2fdE0bVtVVVs2TdW2ZVn2fVm2bWE0Tdk2VVXWTdW0bVmWbWG2ZeF2Zdm3ZVv2ddeVdV/XfePXZd3murLty7Kt+6qr+rbu+8Jw667wCgAAGHAAAAgwoQwUGrISAIgCAACMYYwxCI1SzjkHoVHKOecgZM5BCCGVzDkIIZSSOQehlJQy5yCUklIIoZSUWgshlJRSawUAABQ4AAAE2KApsThAoSErAYBUAACD41iW55miatqyY0meJ4qqqaq27UiW54miaaqqbVueJ4qmqaqu6+ua54miaaqq6+q6aJqmqaqu67q6Lpqiqaqq67qyrpumqqquK7uy7Oumqqqq68quLPvCqrquK8uybevCsKqu68qybNu2b9y6ruu+7/vCka3rui78wjEMRwEA4AkOAEAFNqyOcFI0FlhoyEoAIAMAgDAGIYMQQgYhhJBSSiGllBIAADDgAAAQYEIZKDRkRQAQJwAAGEMppJRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkgppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkqppJRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoplVJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSCgCQinAAkHowoQwUGrISAEgFAACMUUopxpyDEDHmGGPQSSgpYsw5xhyUklLlHIQQUmktt8o5CCGk1FJtmXNSWosx5hgz56SkFFvNOYdSUoux5ppr7qS0VmuuNedaWqs115xzzbm0FmuuOdecc8sx15xzzjnnGHPOOeecc84FAOA0OACAHtiwOsJJ0VhgoSErAYBUAAACGaUYc8456BBSjDnnHIQQIoUYc845CCFUjDnnHHQQQqgYc8w5CCGEkDnnHIQQQgghcw466CCEEEIHHYQQQgihlM5BCCGEEEooIYQQQgghhBA6CCGEEEIIIYQQQgghhFJKCCGEEEIJoZRQAABggQMAQIANqyOcFI0FFhqyEgAAAgCAHJagUs6EQY5Bjw1BylEzDUJMOdGZYk5qMxVTkDkQnXQSGWpB2V4yCwAAgCAAIMAEEBggKPhCCIgxAABBiMwQCYVVsMCgDBoc5gHAA0SERACQmKBIu7iALgNc0MVdB0IIQhCCWBxAAQk4OOGGJ97whBucoFNU6iAAAAAAAAwA4AEA4KAAIiKaq7C4wMjQ2ODo8AgAAAAAABYA+AAAOD6AiIjmKiwuMDI0Njg6PAIAAAAAAAAAAICAgAAAAAAAQAAAAICAT2dnUwAENzsAAAAAAADYxeALAgAAAHud7P0RFEtEQEZDQUJEQDw6NC8bAQHc2OXVdp89CgAAAPCN+ffe+yQOAFrYrZlXxiaEI99H/2IdOAMk2AQ47AAAAAAAuMYZoIdpWKhU/gJQQ7zYUru/w0THv4wiObRV4f3E1sAQ9impgWGyjzm2TmDEr63zAN75NdbmEb8QCN/jXWx4PHd4nZRksg0gGGUAAAAAAMCX9Xv2YwMBzzIoUWBZ5bqVLs9PadxTi3pP/sbhm7HX37ulQgAA3ukt6p+1ecUVFul9nD4lHl0ZOGrAYQGEAgAAAAAAY1M2ra1MP+w/OajzVwCBSRwtTfCAv/BvPnATJk9A3Kw3Ah4JxrnNI29hXO6fI3YaHl7fYChha8kmQF0BAAAAAABcNuDLT+s9bv8yMASgJKCyZSW9nOadvsIU8sLF7Lzep0s/zi8wAAA++eXD/6XXx7RPP3ao/UupVebBnW/ATgE2gNk+AwAAAABwdw9jN23UQVVrrQR6BoBDwA7AR40/OqqG+YbEm7WAC6gCXunFyj8/+RRL/l2wI7XTeOihHpHBBh0AcCAAAAAAABB5Z21fby8VpFowtpUBcDEK9lud0BsL2Kdrg+vkg751+wK+CB5A/4u+F8peqZfM+dnhEUv6tFlwGQDGDAAAAACAvuw5UsnfYz8V8X3hRwJwIhgZ/xk5VHXWCC7e3CkGiINoEgDeCM5y/yNQRiJGcNXthxPqKg8IxySwTQfAKQCQGAAAAACA6kvef+I9098hrAffJ0AhAgXsADAA8vNYrpdzBf7/VjL2At74tcnNpQ7lnh7W8OOr1vEAY5xACdyAdASAfVVFAAAAAADA90j8/jxae2hNPvG3AUAbAADQjnaUABkwDCMCYAL++IX+U+KVDD/15RV+XFdX4wHOiWUDuAHHEQD8fg0AAAAAAACA9uWY22jGqMeo/hsACBYAACjTAAD8GAeeyIXTfxJuBbv98nBK/WpdOi4APVJPHgHA86UAAAAAAAAAAGgvqfUPAAC8c60m4uzVsYD+TRUA9Msqnsgd7+/v5hXOh895xM+T8uMBgK0BBbCOAKAPAAAAAAAAAAD4BFEAsBMAngEAAHARAMDPAJ7I3V6v+m5Y2IuX28PtWcAECwDGJBAAAAAAAAAAUGEzVgD/MyC/3A1wVgVcuEYBnsj99yxfpgBuAEIBAAAAADCEROGDiXOygEEBDg4=" );
       this.healAudio = new Audio( "data:audio/ogg;base64,T2dnUwACAAAAAAAAAAAs+c4UAAAAAEtY0q4BHgF2b3JiaXMAAAAAAUAfAAAAAAAAsDYAAAAAAACZAU9nZ1MAAAAAAAAAAAAALPnOFAEAAAD2m1wWCzz///////////+1A3ZvcmJpcywAAABYaXBoLk9yZyBsaWJWb3JiaXMgSSAyMDE1MDEwNSAo4puE4puE4puE4puEKQAAAAABBXZvcmJpcxJCQ1YBAAABAAxSFCElGVNKYwiVUlIpBR1jUFtHHWPUOUYhZBBTiEkZpXtPKpVYSsgRUlgpRR1TTFNJlVKWKUUdYxRTSCFT1jFloXMUS4ZJCSVsTa50FkvomWOWMUYdY85aSp1j1jFFHWNSUkmhcxg6ZiVkFDpGxehifDA6laJCKL7H3lLpLYWKW4q91xpT6y2EGEtpwQhhc+211dxKasUYY4wxxsXiUyiC0JBVAAABAABABAFCQ1YBAAoAAMJQDEVRgNCQVQBABgCAABRFcRTHcRxHkiTLAkJDVgEAQAAAAgAAKI7hKJIjSZJkWZZlWZameZaouaov+64u667t6roOhIasBADIAAAYhiGH3knMkFOQSSYpVcw5CKH1DjnlFGTSUsaYYoxRzpBTDDEFMYbQKYUQ1E45pQwiCENInWTOIEs96OBi5zgQGrIiAIgCAACMQYwhxpBzDEoGIXKOScggRM45KZ2UTEoorbSWSQktldYi55yUTkompbQWUsuklNZCKwUAAAQ4AAAEWAiFhqwIAKIAABCDkFJIKcSUYk4xh5RSjinHkFLMOcWYcowx6CBUzDHIHIRIKcUYc0455iBkDCrmHIQMMgEAAAEOAAABFkKhISsCgDgBAIMkaZqlaaJoaZooeqaoqqIoqqrleabpmaaqeqKpqqaquq6pqq5seZ5peqaoqp4pqqqpqq5rqqrriqpqy6ar2rbpqrbsyrJuu7Ks256qyrapurJuqq5tu7Js664s27rkearqmabreqbpuqrr2rLqurLtmabriqor26bryrLryratyrKua6bpuqKr2q6purLtyq5tu7Ks+6br6rbqyrquyrLu27au+7KtC7vourauyq6uq7Ks67It67Zs20LJ81TVM03X9UzTdVXXtW3VdW1bM03XNV1XlkXVdWXVlXVddWVb90zTdU1XlWXTVWVZlWXddmVXl0XXtW1Vln1ddWVfl23d92VZ133TdXVblWXbV2VZ92Vd94VZt33dU1VbN11X103X1X1b131htm3fF11X11XZ1oVVlnXf1n1lmHWdMLqurqu27OuqLOu+ruvGMOu6MKy6bfyurQvDq+vGseu+rty+j2rbvvDqtjG8um4cu7Abv+37xrGpqm2brqvrpivrumzrvm/runGMrqvrqiz7uurKvm/ruvDrvi8Mo+vquirLurDasq/Lui4Mu64bw2rbwu7aunDMsi4Mt+8rx68LQ9W2heHVdaOr28ZvC8PSN3a+AACAAQcAgAATykChISsCgDgBAAYhCBVjECrGIIQQUgohpFQxBiFjDkrGHJQQSkkhlNIqxiBkjknIHJMQSmiplNBKKKWlUEpLoZTWUmotptRaDKG0FEpprZTSWmopttRSbBVjEDLnpGSOSSiltFZKaSlzTErGoKQOQiqlpNJKSa1lzknJoKPSOUippNJSSam1UEproZTWSkqxpdJKba3FGkppLaTSWkmptdRSba21WiPGIGSMQcmck1JKSamU0lrmnJQOOiqZg5JKKamVklKsmJPSQSglg4xKSaW1kkoroZTWSkqxhVJaa63VmFJLNZSSWkmpxVBKa621GlMrNYVQUgultBZKaa21VmtqLbZQQmuhpBZLKjG1FmNtrcUYSmmtpBJbKanFFluNrbVYU0s1lpJibK3V2EotOdZaa0ot1tJSjK21mFtMucVYaw0ltBZKaa2U0lpKrcXWWq2hlNZKKrGVklpsrdXYWow1lNJiKSm1kEpsrbVYW2w1ppZibLHVWFKLMcZYc0u11ZRai621WEsrNcYYa2415VIAAMCAAwBAgAlloNCQlQBAFAAAYAxjjEFoFHLMOSmNUs45JyVzDkIIKWXOQQghpc45CKW01DkHoZSUQikppRRbKCWl1losAACgwAEAIMAGTYnFAQoNWQkARAEAIMYoxRiExiClGIPQGKMUYxAqpRhzDkKlFGPOQcgYc85BKRljzkEnJYQQQimlhBBCKKWUAgAAChwAAAJs0JRYHKDQkBUBQBQAAGAMYgwxhiB0UjopEYRMSielkRJaCylllkqKJcbMWomtxNhICa2F1jJrJcbSYkatxFhiKgAA7MABAOzAQig0ZCUAkAcAQBijFGPOOWcQYsw5CCE0CDHmHIQQKsaccw5CCBVjzjkHIYTOOecghBBC55xzEEIIoYMQQgillNJBCCGEUkrpIIQQQimldBBCCKGUUgoAACpwAAAIsFFkc4KRoEJDVgIAeQAAgDFKOSclpUYpxiCkFFujFGMQUmqtYgxCSq3FWDEGIaXWYuwgpNRajLV2EFJqLcZaQ0qtxVhrziGl1mKsNdfUWoy15tx7ai3GWnPOuQAA3AUHALADG0U2JxgJKjRkJQCQBwBAIKQUY4w5h5RijDHnnENKMcaYc84pxhhzzjnnFGOMOeecc4wx55xzzjnGmHPOOeecc84556CDkDnnnHPQQeicc845CCF0zjnnHIQQCgAAKnAAAAiwUWRzgpGgQkNWAgDhAACAMZRSSimllFJKqKOUUkoppZRSAiGllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimVUkoppZRSSimllFJKKaUAIN8KBwD/BxtnWEk6KxwNLjRkJQAQDgAAGMMYhIw5JyWlhjEIpXROSkklNYxBKKVzElJKKYPQWmqlpNJSShmElGILIZWUWgqltFZrKam1lFIoKcUaS0qppdYy5ySkklpLrbaYOQelpNZaaq3FEEJKsbXWUmuxdVJSSa211lptLaSUWmstxtZibCWlllprqcXWWkyptRZbSy3G1mJLrcXYYosxxhoLAOBucACASLBxhpWks8LR4EJDVgIAIQEABDJKOeecgxBCCCFSijHnoIMQQgghREox5pyDEEIIIYSMMecghBBCCKGUkDHmHIQQQgghhFI65yCEUEoJpZRSSucchBBCCKWUUkoJIYQQQiillFJKKSGEEEoppZRSSiklhBBCKKWUUkoppYQQQiillFJKKaWUEEIopZRSSimllBJCCKGUUkoppZRSQgillFJKKaWUUkooIYRSSimllFJKCSWUUkoppZRSSikhlFJKKaWUUkoppQAAgAMHAIAAI+gko8oibDThwgMQAAAAAgACTACBAYKCUQgChBEIAAAAAAAIAPgAAEgKgIiIaOYMDhASFBYYGhweICIkAAAAAAAAAAAAAAAABE9nZ1MABDQUAAAAAAAALPnOFAIAAABuwlK3FjM2ODQ7OjE8ODM8NSctLCowJykkAQGuaZ1jRV3ApACQsa/Labe2Jhb8cuV/5wEAAOx4LzoAW7bE6kaYu3y9AvMSohr78kzYNwCuagJUJYAYJRBkOABQr1xebQAAWDFduColcPKfT4sjM3u2HP5SGp104W5S85cXGUpXfip4LQGqbAOSBttqdAAEKhYA4KtrR68pAADA+KzfiY4mMnC22v0rpx9uAxSL+Q+wclHzPM4cR7Wb2HD7AKpqpK0SgHedIMgwAMCloeGOCwCA/dFH84CV+/v/TEWAi3K255YNAKwWffwgg1dfzxnjJQCqqYpqFoD53hCwMPAAAHx9TPr2AcCHjnnyBgA6UydZbbVPGADxKouD6lptGB9Iko2xpv20hVKY2edAAa5rvqcsAP0/o1FgEWgAAFZfkv5JAAx3q3uhslYHAMDr9icmtN3Cms+BpkuXf+jnRG/DJk8lMWR3CwKuq75WvAJQf9VToLNgAABbSH/vug2cf6D9Y3kOADy+yla9lRPwY5XiRAH0GGyt/QAAsqkRn70C0HfKOeXwYJECAJD7mk/Kt6RyPrdM/ubrZAIAbvexub713vtaApBF59A3zcU5OJl44tyWNtgBsquZkWQCwI4qU6OBHAMAgN1Zt5oEgEw/oPtyslrvIgkAAO4voj67OEaMEgFzqOMPdSzi0e8ZzwKyqpltlQkA7MMbOFIJAAA2yJAXRt76AAC1umq/u/qZPlcBACEZz+f2+w+AHSsP4sSyKQCuq1Xo0gGqAVCR0wAAgB982ZP+4awAAAAAAPwWRE/2wCz839W1AADwePT3w9O/Pw486JkSKua+yohTEwCyq5n/ZnPAdDoHgFIBoGf/M5gBAOD+/NbTFU4f7kd2DQBAP7ztvd6CYe3rCqDbietmqe8jAK6rVfhmRDKQIrAtfv5x8/9rAAA8RCcDF/5+FQAAgHN13ZpvXY+BCaqsVfjmbAAkKCSAX2w52vN6FwAACO0x9QcQJq6hbdf1gwGMRGXzbl549QBWAK7n0KHANkoCZEiZWf+9b9i6AACg92sDGNOThVN5cuzC/MSli1539Qte9ZMCqu0Qwy8ykXlbAMi0ZAHX1d/Waw0AAPcP7A6AHukovvTk0wEASBpX7pcLpqt1hGP7mIBUAhjmX1z/8p9+91IEAJjH1WQxG4DN8HQxPv9a7SgC4Hsd553iME4BputIHrFZbaMGkAAGaNufXj92ogBgLBnJR6a8382seQDAuV5qi68GnuboKNswIAGHAPCDaDdOv9MDALret+JqYGeyOLrwta/PSgkA7KqPDwCC5eBYbgUtgtkQV5NzDAEA1PDjj3cvJAAAePjLnz2NTuB6MQAAAA==" );
   }

   ouchFx() {
      this.ouchAudio.play();
   }

   walkSfx() {
      (new Audio( "data:audio/ogg;base64,T2dnUwACAAAAAAAAAAAER3N7AAAAAKnicT0BHgF2b3JiaXMAAAAAAUAfAAAAAAAAsDYAAAAAAACZAU9nZ1MAAAAAAAAAAAAABEdzewEAAACclrl8Czz///////////+1A3ZvcmJpcywAAABYaXBoLk9yZyBsaWJWb3JiaXMgSSAyMDE1MDEwNSAo4puE4puE4puE4puEKQAAAAABBXZvcmJpcxJCQ1YBAAABAAxSFCElGVNKYwiVUlIpBR1jUFtHHWPUOUYhZBBTiEkZpXtPKpVYSsgRUlgpRR1TTFNJlVKWKUUdYxRTSCFT1jFloXMUS4ZJCSVsTa50FkvomWOWMUYdY85aSp1j1jFFHWNSUkmhcxg6ZiVkFDpGxehifDA6laJCKL7H3lLpLYWKW4q91xpT6y2EGEtpwQhhc+211dxKasUYY4wxxsXiUyiC0JBVAAABAABABAFCQ1YBAAoAAMJQDEVRgNCQVQBABgCAABRFcRTHcRxHkiTLAkJDVgEAQAAAAgAAKI7hKJIjSZJkWZZlWZameZaouaov+64u667t6roOhIasBADIAAAYhiGH3knMkFOQSSYpVcw5CKH1DjnlFGTSUsaYYoxRzpBTDDEFMYbQKYUQ1E45pQwiCENInWTOIEs96OBi5zgQGrIiAIgCAACMQYwhxpBzDEoGIXKOScggRM45KZ2UTEoorbSWSQktldYi55yUTkompbQWUsuklNZCKwUAAAQ4AAAEWAiFhqwIAKIAABCDkFJIKcSUYk4xh5RSjinHkFLMOcWYcowx6CBUzDHIHIRIKcUYc0455iBkDCrmHIQMMgEAAAEOAAABFkKhISsCgDgBAIMkaZqlaaJoaZooeqaoqqIoqqrleabpmaaqeqKpqqaquq6pqq5seZ5peqaoqp4pqqqpqq5rqqrriqpqy6ar2rbpqrbsyrJuu7Ks256qyrapurJuqq5tu7Js664s27rkearqmabreqbpuqrr2rLqurLtmabriqor26bryrLryratyrKua6bpuqKr2q6purLtyq5tu7Ks+6br6rbqyrquyrLu27au+7KtC7vourauyq6uq7Ks67It67Zs20LJ81TVM03X9UzTdVXXtW3VdW1bM03XNV1XlkXVdWXVlXVddWVb90zTdU1XlWXTVWVZlWXddmVXl0XXtW1Vln1ddWVfl23d92VZ133TdXVblWXbV2VZ92Vd94VZt33dU1VbN11X103X1X1b131htm3fF11X11XZ1oVVlnXf1n1lmHWdMLqurqu27OuqLOu+ruvGMOu6MKy6bfyurQvDq+vGseu+rty+j2rbvvDqtjG8um4cu7Abv+37xrGpqm2brqvrpivrumzrvm/runGMrqvrqiz7uurKvm/ruvDrvi8Mo+vquirLurDasq/Lui4Mu64bw2rbwu7aunDMsi4Mt+8rx68LQ9W2heHVdaOr28ZvC8PSN3a+AACAAQcAgAATykChISsCgDgBAAYhCBVjECrGIIQQUgohpFQxBiFjDkrGHJQQSkkhlNIqxiBkjknIHJMQSmiplNBKKKWlUEpLoZTWUmotptRaDKG0FEpprZTSWmopttRSbBVjEDLnpGSOSSiltFZKaSlzTErGoKQOQiqlpNJKSa1lzknJoKPSOUippNJSSam1UEproZTWSkqxpdJKba3FGkppLaTSWkmptdRSba21WiPGIGSMQcmck1JKSamU0lrmnJQOOiqZg5JKKamVklKsmJPSQSglg4xKSaW1kkoroZTWSkqxhVJaa63VmFJLNZSSWkmpxVBKa621GlMrNYVQUgultBZKaa21VmtqLbZQQmuhpBZLKjG1FmNtrcUYSmmtpBJbKanFFluNrbVYU0s1lpJibK3V2EotOdZaa0ot1tJSjK21mFtMucVYaw0ltBZKaa2U0lpKrcXWWq2hlNZKKrGVklpsrdXYWow1lNJiKSm1kEpsrbVYW2w1ppZibLHVWFKLMcZYc0u11ZRai621WEsrNcYYa2415VIAAMCAAwBAgAlloNCQlQBAFAAAYAxjjEFoFHLMOSmNUs45JyVzDkIIKWXOQQghpc45CKW01DkHoZSUQikppRRbKCWl1losAACgwAEAIMAGTYnFAQoNWQkARAEAIMYoxRiExiClGIPQGKMUYxAqpRhzDkKlFGPOQcgYc85BKRljzkEnJYQQQimlhBBCKKWUAgAAChwAAAJs0JRYHKDQkBUBQBQAAGAMYgwxhiB0UjopEYRMSielkRJaCylllkqKJcbMWomtxNhICa2F1jJrJcbSYkatxFhiKgAA7MABAOzAQig0ZCUAkAcAQBijFGPOOWcQYsw5CCE0CDHmHIQQKsaccw5CCBVjzjkHIYTOOecghBBC55xzEEIIoYMQQgillNJBCCGEUkrpIIQQQimldBBCCKGUUgoAACpwAAAIsFFkc4KRoEJDVgIAeQAAgDFKOSclpUYpxiCkFFujFGMQUmqtYgxCSq3FWDEGIaXWYuwgpNRajLV2EFJqLcZaQ0qtxVhrziGl1mKsNdfUWoy15tx7ai3GWnPOuQAA3AUHALADG0U2JxgJKjRkJQCQBwBAIKQUY4w5h5RijDHnnENKMcaYc84pxhhzzjnnFGOMOeecc4wx55xzzjnGmHPOOeecc84556CDkDnnnHPQQeicc845CCF0zjnnHIQQCgAAKnAAAAiwUWRzgpGgQkNWAgDhAACAMZRSSimllFJKqKOUUkoppZRSAiGllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimVUkoppZRSSimllFJKKaUAIN8KBwD/BxtnWEk6KxwNLjRkJQAQDgAAGMMYhIw5JyWlhjEIpXROSkklNYxBKKVzElJKKYPQWmqlpNJSShmElGILIZWUWgqltFZrKam1lFIoKcUaS0qppdYy5ySkklpLrbaYOQelpNZaaq3FEEJKsbXWUmuxdVJSSa211lptLaSUWmstxtZibCWlllprqcXWWkyptRZbSy3G1mJLrcXYYosxxhoLAOBucACASLBxhpWks8LR4EJDVgIAIQEABDJKOeecgxBCCCFSijHnoIMQQgghREox5pyDEEIIIYSMMecghBBCCKGUkDHmHIQQQgghhFI65yCEUEoJpZRSSucchBBCCKWUUkoJIYQQQiillFJKKSGEEEoppZRSSiklhBBCKKWUUkoppYQQQiillFJKKaWUEEIopZRSSimllBJCCKGUUkoppZRSQgillFJKKaWUUkooIYRSSimllFJKCSWUUkoppZRSSikhlFJKKaWUUkoppQAAgAMHAIAAI+gko8oibDThwgMQAAAAAgACTACBAYKCUQgChBEIAAAAAAAIAPgAAEgKgIiIaOYMDhASFBYYGhweICIkAAAAAAAAAAAAAAAABE9nZ1MABGwMAAAAAAAABEdzewIAAAAvJcoWDkVCR0k7ODk6PUY/OTkvjhfntxSLIsUAvkvWMq7pu5aVlKh8M6cdc9exWbs/69iOKgiEbB/bON+Er5kRtZRVq9oiIVWC0X+YRmlTMfQS01PxHyYAjhu3H4paJmBwbgrLENRwk9QhETtpxA0WeoZfJzWMB0XUq9Mh/bd1KmFQaZajQUaz09ctLCnw3p6i6LrL2n4ynW0CipySFrVUkS+CALLpje7lkSNFg3Bw3suPf/nxu/hGEQVAECif14UEIhtp5/MXBZ8H3/peHld6oByZR/XteAdFDKS69KeWYQ+uYz5IzaMSN6aVmJ/5rfbjMr9o2sP5HrzZg/Oh2516f9N0zwaQyqX+ZgtP785TcmcN3uzBiUPlgnJR53b3s+43lqShlb2fcSoAgiHSUYAaOio2QSvoWFefN0RVyh6dbdrwyfb05L1uI819GEN8fGThsnruK9q3Okbvd7nAF83XwK93AQCKHkcPRYacxkAf2Kt0zFp2jmDyUw7AcE1QEV0FSvPmtTF0Qr/AdxxN736KvcJb0bImFRHvEdGrAI4d1x8WxlSckHsU6tOH3LkZliZbV3c8AnlSH0fgyZRyoq4jZQcDmAo8l7AeV/Li655rgrmyGqYrAI4dd2+3KCx0gnr3zPl85Ek0zmBFE2FfpheeVnWONEweSOWnIe2+0LnWq5hyg+DIWHcegrFhmtHGHgCKnNY7CiuVY2hRzJJPIEibVYd9w9R7zifeWuvymcyZHUWKXn1VDKieB1aprhRaxibK2cqVNknDbHul5zEApqS4LGrjM/j54tjY3ubTzF6HfewZC344X16f18fLvRdERgIwyMShv5ye58fl4EUSsSSyfTSA3a/qMjdOBP7Y64/NGuUCAIKgbLUAgaRAm5BdneXXq5c6RP3wj8pJgBt9vkw+zO1KTdjuK7Uxm4x3zR8cPTO97m6ocLsVtfkjrwi7hvIkAIody06DQC7DCuW0IX9vLx0a7dSIuTvnOnJzwFXSwuVRHVkjXWyvFalk2x8kk8gs8sxA+u3ZJcydAI4d5xeFRUZjGPnkY0v8jIsV3Exa+BAyjEd+vu7jo5+29xDy2d1bfqqIFAD1Fx6QXR/WZVDnnu03AYoZbwuqQkvBF+COHL0TADiN8QM91km0zPoHe+aEnH5LGZxLqYFu/EBpDDBRfaMA" )).play();
   }

   pickupSfx() {
      this.pickupAudio.play();
   }

   healSfx() {
      this.healAudio.play();
   }
}

class Messenger {
   constructor(reactComponent) {
      this.reactComponent = reactComponent;
   }

   capitalize(text) {
      return text[0].toUpperCase() + text.substring(1);
   }

   sendMessage(text) {
      if ( !this.reactComponent.textarea ) {
         return;
      }

      var lines = this.reactComponent.textarea.value.split("\n");
      while ( lines.length > 4 ) {
         lines.shift();
      }

      var retval = lines.join("\n");
      if ( retval.length > 0 ) {
         retval += "\n";
      }
      retval += this.capitalize(text)+".";
      this.reactComponent.textarea.value = retval;  
   }
}

class GameWorld {
   constructor(reactComponent, messenger, sounds) {
      this.reactComponent = reactComponent;
      this.messenger = messenger;
      this.sounds    = sounds;

      this.gameOver = this.gameOver.bind(this);
      this.winning  = this.winning.bind(this);
      this.heroHpIncreaser = this.heroHpIncreaser.bind(this);
      this.damageInRadius  = this.damageInRadius.bind(this);
      this.enemyGenerator  = this.enemyGenerator.bind(this);
      this.stuffGenerator  = this.stuffGenerator.bind(this);

      function twoColors(colorA, colorB) { return [colorA,colorB,colorA,colorB,colorA,colorB]; }
      function threeColors(colorC, colorA, colorB) { return [colorC,colorB,colorA,colorB,colorA,colorB]; }

      var undeadExHeroColors = ['royalblue','lightgreen','royalblue','green','royalblue','green'];
      var knightColors = threeColors('tomato',SPECIAL_COLORS.DARKGRAY1,SPECIAL_COLORS.DARKGRAY2);
      var zombieColors = twoColors('mediumseagreen','mediumaquamarine');
      var tiefColors = ['orange','royalblue','orange','blue','orange','blue'];
      var evilWoodColors = twoColors(SPECIAL_COLORS.WOODBROWN,SPECIAL_COLORS.WOODBROWN);
      var giantColors = ['orange','limegreen','orange','olive','orange','olive'];
      var strongZombieColors = twoColors('mediumseagreen','mediumaquamarine');
      var masterTiefColors = ['orange','tomato','orange','crimson','orange','crimson'];
      var crazyGiantColors = ['orange','orange','orange','olive','orange','olive'];
      var stoneGolemColors = twoColors(SPECIAL_COLORS.DARKGRAY0,SPECIAL_COLORS.DARKGRAY0);
      var superGenieColors = ['yellow','yellow','yellow',"",'yellow',""];
      this.ATTRIBUTES_OF_ENEMIES = [
             {name:"devilguy",scale:0.75,coloring:twoColors('crimson','tomato'),         slowness:10,range:4,level:1,weakness:2,baseAttack:0,baseDefense:0},
             {name:"ogre"    ,scale:0.9,coloring:twoColors('limegreen','olive'),         slowness: 8,range:5,level:1,weakness:2,baseAttack:0,baseDefense:0},
             {name:"zombie"  ,scale:0.95,coloring:zombieColors,                          slowness:10,range:4,level:2,weakness:2,baseAttack:1,baseDefense:0},
             {name:"thief"   ,scale:1.00,coloring:tiefColors,                            slowness: 6,range:5,level:2,weakness:2,baseAttack:0,baseDefense:1},
             {name:"ogre warrior",scale:0.9,coloring:twoColors('limegreen','olive'),     slowness: 8,range:5,level:2,weakness:2,baseAttack:0,baseDefense:1,defaultWeapon:ATTRIBUTES_WOODEN_STICK},
             {name:"dwarf",scale:0.6,coloring:twoColors('orange','mediumblue'),          slowness: 5,range:5,level:3,weakness:2,baseAttack:1,baseDefense:0},
             {name:"evil wood",scale:0.90,coloring:evilWoodColors,                       slowness: 9,range:5,level:3,weakness:2,baseAttack:1,baseDefense:2,defaultWeapon:ATTRIBUTES_WOODEN_STICK},
             {name:"tough devilguy",scale:0.80,coloring:twoColors('crimson','tomato'),   slowness: 9,range:5,level:3,weakness:3,baseAttack:1,baseDefense:2,defaultWeapon:ATTRIBUTES_IRON_BAR},
             {name:"giant"   ,scale:1.30,coloring:giantColors,                           slowness: 6,range:5,level:4,weakness:2,baseAttack:1,baseDefense:1},

             {name:"ice golem",scale:0.95,coloring:twoColors('mediumblue','mediumblue'), slowness: 8,range:4,level:4,weakness:3,baseAttack:3,baseDefense:1},
             {name:"strong zombie",scale:1.10,coloring:strongZombieColors,               slowness:10,range:5,level:4,weakness:1,baseAttack:1,baseDefense:1},
             {name:"master thief" ,scale:1.00,coloring:masterTiefColors,                 slowness: 5,range:5,level:5,weakness:4,baseAttack:2,baseDefense:2},
             {name:"ghost"        ,scale:0.90,coloring:twoColors('gray','gray'),         slowness: 7,range:5,level:5,weakness:2,baseAttack:2,baseDefense:3,transparency:0.5},
             {name:"fire elemental",scale:0.95,coloring:twoColors('yellow','yellow'),    slowness: 7,range:5,level:5,weakness:1,baseAttack:2,baseDefense:1},
             {name:"crazy giant"   ,scale:1.30,coloring:crazyGiantColors,                slowness: 8,range:5,level:6,weakness:2,baseAttack:2,baseDefense:3},
             {name:"undead ogre",scale:0.9,coloring:twoColors('royalblue','olive'),      slowness: 9,range:5,level:6,weakness:2,baseAttack:3,baseDefense:3,defaultWeapon:ATTRIBUTES_WOODEN_STICK},
             {name:"blue orb",scale:0.7,coloring:['blue',"","","","",""],                slowness: 8,range:5,level:6,weakness:2,baseAttack:3,baseDefense:4,transparency:0.50},
             {name:"blue daemon",scale:0.85,coloring:twoColors('blue','blue'),           slowness: 5,range:5,level:7,weakness:2,baseAttack:2,baseDefense:3,transparency:0.25},

             {name:"elite dwarf",scale:0.5,coloring:twoColors('orange','mediumblue'),    slowness: 5,range:5,level:7,weakness:3,baseAttack:3,baseDefense:4,defaultWeapon:ATTRIBUTES_WOODEN_STICK},
             {name:"genie",scale:1.1,coloring:['green','green','green',"",'green',""],   slowness: 7,range:5,level:7,weakness:2,baseAttack:4,baseDefense:4,transparency:0.25},
             {name:"stone golem",scale:0.95,coloring:stoneGolemColors,                   slowness: 8,range:4,level:8,weakness:2,baseAttack:4,baseDefense:3},
             {name:"undead ex-hero",scale:1.0,coloring:undeadExHeroColors,               slowness: 5,range:5,level:8,weakness:4,baseAttack:4,baseDefense:3,defaultWeapon:ATTRIBUTES_WOODEN_STICK,defaultShield:ATTRIBUTES_MINISHIELD},
             {name:"hell knight",scale:1.00,coloring:knightColors,                       slowness: 8,range:6,level:8,weakness:2,baseAttack:3,baseDefense:3,defaultWeapon:ATTRIBUTES_IRON_BAR,defaultShield:ATTRIBUTES_MINISHIELD},
             {name:"fire orb",scale:0.7,coloring:['yellow',"","","","",""],              slowness: 8,range:5,level:9,weakness:2,baseAttack:4,baseDefense:5,transparency:0.50},
             {name:"gold dwarf",scale:0.5,coloring:twoColors('gold','orange'),           slowness: 5,range:5,level:9,weakness:4,baseAttack:5,baseDefense:4,defaultWeapon:ATTRIBUTES_IRON_BAR},
             {name:"mercury golem",scale:0.95,coloring:twoColors('silver','silver'),     slowness: 4,range:5,level:9,weakness:3,baseAttack:4,baseDefense:5},
             {name:"super genie",scale:1.1,coloring:superGenieColors,                    slowness: 5,range:5,level:10,weakness:3,baseAttack:4,baseDefense:4,transparency:0.50},

             {name:"diabolito",scale:1.25,coloring:threeColors('crimson',SPECIAL_COLORS.DARKGRAY1,SPECIAL_COLORS.DARKGRAY0),slowness:4,range:6,level:10,weakness:0.5,defaultWeapon:ATTRIBUTES_SILVER_SWORD,defaultShield:ATTRIBUTES_BATTLESHIELD,deathProcedure:this.winning},
         ];

      this.ATTRIBUTES_OF_STUFFS = [
         {name:"health potion",color:"red"                ,width:5,height:5,value:-1,holder:"potions",effect:this.heroHpIncreaser(0.25),effectText:"hero heals"},
         {name:"major health potion",color:"red"                ,width:7,height:7,value:-1,holder:"potions",effect:this.heroHpIncreaser(0.33),effectText:"hero heals"},
         {name:"full health potion",color:"red"                ,width:9,height:9,value:-1,holder:"potions",effect:this.heroHpIncreaser(0.5),effectText:"hero heals"},
         {name:"minor poison gas"   ,color:SPECIAL_COLORS.POISON,width:5,height:5,value:-1,holder:"potions",effect:this.damageInRadius(10,10),effectText:"deadly poison gas is released"},
         {name:"poison gas"         ,color:SPECIAL_COLORS.POISON,width:7,height:7,value:-1,holder:"potions",effect:this.damageInRadius(10,30),effectText:"deadly poison gas is released"},
         {name:"major poison gas"   ,color:SPECIAL_COLORS.POISON,width:0,height:9,value:-1,holder:"potions",effect:this.damageInRadius(10,30),effectText:"deadly poison gas is released"}
      ];

      this.unitBaseHp = 20;
      this.unitHpPerLevelIncrease = 5;

      this.isObjectNotFullyDead = this.isObjectNotFullyDead.bind(this);

      [this.gameMap,this.characters,this.stuffs] = (new MapGenerator()).generateThreeInOneMap(210,70,45,30,4,this.enemyGenerator,this.stuffGenerator);

      // all characters on the map - 0th is the player
      //[[y,x], faceDir (0=S, 1=E, 2=N, 3=W), phase, path, shared_attributes_in_class, attackbit, non_shared_attributes]
      this.characters[0] = this.createHero([2.5,2.5]);
      this.errorTolerance = 0.01;

      this.characterBuckets = new CacheIndexerBuckets();
      this.characterIndex   = undefined;
      this.stuffBuckets     = new CacheIndexerBuckets();
      this.stuffIndex       = undefined;
      this.monsterKillingPerLevelFactor = 30;

      this.walkSfxFrequency = 10;
      this.walkSfxCounter = 10;
      this.aiCounter = 0;
      this.deathSpeed = 1/25;
   }

   createHero(pos) {
      var heroStartingLevel = 1;
      var heroDefaultWeapon = undefined;
      var heroDefaultShield = undefined;
      var hero = [pos,0,0,[],{name:"hero",scale:1.00,coloring:['orange','lightgreen','orange','green','orange','green'],slowness:5,range:50,level:heroStartingLevel,deathProcedure:this.gameOver},0,{xp:0,exists:1,weapon:heroDefaultWeapon,shield:heroDefaultShield,potions:[undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined]}];
      hero[4].baseHp = this.getBaseHp(hero[4].level);
      hero[6].hp     = hero[4].baseHp;
      return hero;
   }

   winning() {
      this.messenger.sendMessage("hero won the game");
   }

   gameOver() {
      this.messenger.sendMessage("game over");
   }

   heroHpIncreaser(percentage) {
      return ()=>{ var value = Math.floor(this.getCharacterSharedAttributes(0).baseHp * percentage);
                   return this.isCharacterAlive(0)
                       && (this.getCharacterUniqueAttributes(0).hp < this.getCharacterSharedAttributes(0).baseHp)
                       && (this.getCharacterUniqueAttributes(0).hp=Math.min(this.getCharacterSharedAttributes(0).baseHp,this.getCharacterUniqueAttributes(0).hp+value))
                       && (this.sounds.healSfx() || 1)
                       && (this.reactComponent.refreshHpValues() || 1); };
   }

   damageInRadius(radius, value) {
      return ()=>{
         this.characterBuckets.iterateOverBucketItemsAroundPos(this.getCharacterPosition(0),
                                                               (i)=>{
                                                                   if ( this.manhattan(this.getCharacterPosition(0), this.getCharacterPosition(i)) < radius ) {
                                                                      if ( this.damage(i, value) ) {
                                                                         this.awardXp(0, i);
                                                                      };
                                                                   }
                                                               });
         return 1;
      };
   }

   createMonster(pos,attributes) {
      attributes.baseHp = Math.floor(this.getBaseHp(attributes.level)/attributes.weakness/2);
      return [pos,0,0,[],attributes,0,{hp: attributes.baseHp,exists:1,weapon:attributes.defaultWeapon,shield:attributes.defaultShield}];
   }

   createStuff(pos,attributes) { return [pos,0,0,[],attributes,0,{exists:1}]; }

   posAdjustment([y,x]) { return [y+0.5,x+0.5]; }

   enemyGenerator(pos, code) {
      return this.createMonster(this.posAdjustment(pos),this.ATTRIBUTES_OF_ENEMIES[code]);
   }

   stuffGenerator(pos, code) {
      if ( code == 0 ) {
         return this.createStuff(this.posAdjustment(pos),this.ATTRIBUTES_OF_STUFFS[0]);
      } else if ( code == 1 ) {
         return this.createStuff(this.posAdjustment(pos),this.ATTRIBUTES_OF_STUFFS[3]);
      } else if ( code % 2 == 0 ) {
         var weapon = [ATTRIBUTES_WOODEN_STICK,
                      ATTRIBUTES_IRON_BAR,
                      ATTRIBUTES_STEEL_SWORD,
                      ATTRIBUTES_SILVER_SWORD,
                      ATTRIBUTES_GOLD_SWORD,
                      ATTRIBUTES_CRISTAL_SWORD][(code-2)/2];
         return this.createStuff(this.posAdjustment(pos),weapon);
      } else {
         var shield = [ATTRIBUTES_MINISHIELD,
                      ATTRIBUTES_BUCKLER_SHIELD,
                      ATTRIBUTES_BATTLESHIELD,
                      ATTRIBUTES_KITE_SHIELD,
                      ATTRIBUTES_TOWER_SHIELD,  
                      ATTRIBUTES_TOWER_SHIELD][(code-3)/2];
         return this.createStuff(this.posAdjustment(pos),shield);
      }
   }

   getKey(diri,phi) { return (1+diri*2)*9 + phi; }
   magicFunction(x) { return Math.floor((Math.pow(1.11,x)-1)*10); }

   getCharacterPosition(i)            { return this.characters[i][0]; }
   getCharacterPositionFloor(i)       { return [Math.floor(this.characters[i][0][0]),Math.floor(this.characters[i][0][1])]; }
   getCharacterPositionFloorObj(i)    { return {y:Math.floor(this.characters[i][0][0]),x:Math.floor(this.characters[i][0][1])}; }
   setCharacterPosition(i,pos)        { this.characters[i][0] = pos; }
   setCharacterPositionCoord(i,c,val) { this.characters[i][0][c] = val; }
   getCharacterFaceDir(i)             { return this.characters[i][1]; }
   getCharacterPhase(i)               { return this.characters[i][2]; }
   resetCharacterPhase(i)             { this.characters[i][2] = 0; }
   setCharacterFaceDir(i,a,b)         { this.characters[i][1] = 2 * ( a < 0 ) + b };
   increaseCharacterPhase(i)          { this.characters[i][2] = (this.characters[i][2] % 8 ) + 1; }
   getCharacterPath(i)                { return this.characters[i][3]; }
   isCharacterPathTargetAlreadySet(i, target) {
      return ( this.getCharacterPath(i).length
            && this.getCharacterPath(i)[this.getCharacterPath(i).length-1][1] == target.x 
            && this.getCharacterPath(i)[this.getCharacterPath(i).length-1][0] == target.y );
   }

   removeCharacterFirstPathChain(i)   { this.characters[i][3].reverse();this.characters[i][3].pop();this.characters[i][3].reverse(); }
   setCharacterPath(i,path) {
      if ( path === undefined || path.length == 0 ) {
         return;
      }
      this.characters[i][3] = path;
   }
   setCharacterPathWithBfs(i, target) { 
      if ( target === undefined || this.isCharacterPathTargetAlreadySet(i, target) ) {
         return;
      }

      if ( this.getCharacterPath(i).length ) {
         var source = {y:this.getCharacterPath(i)[0][0],x:this.getCharacterPath(i)[0][1]};
         this.setCharacterPath(i, [this.getCharacterPath(i)[0]].concat(this.bfs(i,source, target)));
      } else {
         this.setCharacterPath(i, this.bfs(i,this.getCharacterPositionFloorObj(i), target));
      }
   }
   getCharacterAnimationKey(i)     { return this.getKey(this.getCharacterFaceDir(i), this.getCharacterPhase(i)); }
   getCharacterSharedAttributes(i) { return this.characters[i][4]; }
   getCharacterAttackBit(i)        { return this.characters[i][5]; }
   eraseCharacterAttackBit(i)      { this.characters[i][5] = 0; }
   setCharacterAttackBit(i)        { this.characters[i][5] = 1; }
   getCharacterUniqueAttributes(i) { return this.characters[i][6]; }

   getStuffPosition(i)             { return this.stuffs[i][0]; }
   getStuffSharedAttributes(i)     { return this.stuffs[i][4]; }
   setStuffSharedAttributes(i,val) { this.stuffs[i][4] = val; }
   getStuffUniqueAttributes(i)     { return this.stuffs[i][6]; }

   getCharacterBaseAttack(i)  { return this.magicFunction(this.getCharacterSharedAttributes(i).level)+(this.getCharacterSharedAttributes(i).baseAttack?this.getCharacterSharedAttributes(i).baseAttack:0); }
   getCharacterBaseDefense(i) {
   
   return Math.max(0,this.magicFunction(this.getCharacterSharedAttributes(i).level)-2+(this.getCharacterSharedAttributes(i).baseDefense?this.getCharacterSharedAttributes(i).baseDefense:0));
   }
 
   getCharacterHoldedObjectAttribute(i,holder,attribute) { return (this.getCharacterUniqueAttributes(i)[holder]||ATTRIBUTES_BAREFIST)[attribute]; }

   getCharacterAnimationWeaponShieldValue(i) {
      return (this.getCharacterHoldedObjectAttribute(i,"weapon","value") != 0)
           + (this.getCharacterHoldedObjectAttribute(i,"shield","value") != 0)*2;
   }

   getMapCell(y,x) {
      return ( y < this.gameMap.length && y >= 0 && x < this.gameMap[y].length && x >= 0 ? this.gameMap[y][x] : 0 );
   }

   isCharacterAlive(index) {
      return ( this.getCharacterUniqueAttributes(index).exists > 1 - this.errorTolerance );
   }

   isCharacterFullyDead(index) {
      return ( this.getCharacterUniqueAttributes(index).exists < this.errorTolerance );
   }

   isObjectNotFullyDead(obi) {
      return !( obi[6].exists < this.errorTolerance );
   }

   isCharacterAtCellCenter(index) {
      return Math.abs(this.getCharacterPosition(index)[0] - Math.floor(this.getCharacterPosition(index)[0]) - 0.5) < this.errorTolerance
          && Math.abs(this.getCharacterPosition(index)[1] - Math.floor(this.getCharacterPosition(index)[1]) - 0.5) < this.errorTolerance;
   }

   refreshCharacterIndex() {
      this.characterIndex = this.characterBuckets.createIndexFromBuckets(this.characters, this.isObjectNotFullyDead, this.getCharacterPosition(0));
   }

   getCharacterIndexFromPosition(pos) {
      if ( this.characterIndex === undefined ) {
         refreshCharacterIndex();
      }
      return this.characterIndex[this.characterBuckets.getIndexKey(pos)];
   }

   iterateOverCharactersAroundHero(func) {
      this.characterBuckets.iterateOverBucketItemsAroundPos(this.getCharacterPosition(0), func);
   }

   refreshStuffIndex() {
      this.stuffIndex = this.stuffBuckets.createIndexFromBuckets(this.stuffs, this.isObjectNotFullyDead, this.getCharacterPosition(0));
   }

   getStuffIndexFromPosition(pos) {
      if ( this.stuffIndex === undefined ) {
         refreshStuffIndex();
      }
      return this.stuffIndex[this.stuffBuckets.getIndexKey(pos)];
   }

   bfs(index,source,target) {
      if ( !this.getMapCell(source.y,source.x) ) {
         return [];
      }
      var hops = {};
      var findings = [[source.y,source.x]];
      hops[findings[0]]=false;
      var level = 0;
      var dirs = [[0,1],[-1,0],[0,-1],[1,0]];
      while ( level < 10 && findings.length > 0 ) {
         ++level;
         var nfindings = [];
         for ( var i = 0; i < findings.length; ++i ) {
            for ( var j = 0; j < dirs.length; ++j ) {
               var nextp = [(findings[i][0]+dirs[j][1]),(findings[i][1]+dirs[j][0])];
               if ( this.getMapCell(nextp[0],nextp[1]) && this.getMapCell(nextp[0],nextp[1]) < 6 + 1
                 && hops[nextp] === undefined
                 && ( nextp[0] === target.y && nextp[1] === target.x 
                   || this.getCharacterIndexFromPosition([nextp[0],nextp[1]]) === undefined
                   || this.getCharacterIndexFromPosition([nextp[0],nextp[1]]) === index ) ) { // enemies shadowing the areas behind of them, but not themselves
                  nfindings.push(nextp);
                  hops[nextp] = findings[i];
               }
            }
         }
         findings = nfindings;
      }
      var tara = [target.y,target.x];
      var way = [];
      if ( hops[tara] !== undefined ) {
         way.push(tara);
         var maxi = 100;
         while(hops[tara] && maxi--) {
            way.push(hops[tara]);
            tara = hops[tara];
         }
      }
      way.reverse();
      return way;
   }

   tryingToUsePotion() {
      if ( this.getCharacterUniqueAttributes(0).setUsePotion === undefined
        || this.getCharacterUniqueAttributes(0).potions === undefined
        || this.getCharacterUniqueAttributes(0).setUsePotion >= this.getCharacterUniqueAttributes(0).potions.length
        || this.getCharacterUniqueAttributes(0).potions[this.getCharacterUniqueAttributes(0).setUsePotion] === undefined ) {
         return;
      }
      var exec = this.getCharacterUniqueAttributes(0).potions[this.getCharacterUniqueAttributes(0).setUsePotion];
      this.getCharacterUniqueAttributes(0).potions[this.getCharacterUniqueAttributes(0).setUsePotion] = undefined;
      if ( exec.effect() ) {
         this.messenger.sendMessage('Hero uses '+exec.name+', '+exec.effectText);
      } else {
         this.messenger.sendMessage('Hero uses '+exec.name+', but nothing happens');
      }
      this.pickupAttempt(0,1);
      this.reactComponent.refreshPotionBelt();
      this.getCharacterUniqueAttributes(0).setUsePotion = undefined;
   }

   pickupAttempt(index,forgiving) {
      this.refreshStuffIndex();
      if ( (this.getCharacterPhase(index) != 0 || forgiving) && this.isCharacterAtCellCenter(index) ) {
         var stuff = this.getStuffIndexFromPosition(this.getCharacterPosition(index));
         if ( stuff !== undefined && this.getStuffUniqueAttributes(stuff).exists ) {
            this.pickup(index,stuff);
         }
      }
   }

   pickup(index,stuff) {
      var holder  = this.getStuffSharedAttributes(stuff).holder;
      var current = this.getCharacterHoldedObjectAttribute(index,holder,"value");
      var whatif  = this.getStuffSharedAttributes(stuff).value;
      if (whatif >= 0 ) {
         // hero hold can only once from it at a time, value decides
         if ( whatif > current ) {
            if ( current ) {
               this.messenger.sendMessage(this.getCharacterSharedAttributes(index).name + " drops " + this.getCharacterUniqueAttributes(index)[holder].name + " and picks up " + this.getStuffSharedAttributes(stuff).name);
               this.sounds.pickupSfx();
               var tmp = this.getStuffSharedAttributes(stuff);
               this.setStuffSharedAttributes(stuff,this.getCharacterUniqueAttributes(index)[holder]);
               this.getCharacterUniqueAttributes(index)[holder] = tmp;
            } else {
               this.messenger.sendMessage(this.getCharacterSharedAttributes(index).name + " picks up " + this.getStuffSharedAttributes(stuff).name);
               this.sounds.pickupSfx();
               this.getCharacterUniqueAttributes(index)[holder] = this.getStuffSharedAttributes(stuff);
               this.getStuffUniqueAttributes(stuff).exists = 0;
            }
         }
      } else {
         // hero can hold multiple from it, and there is no precedence between objects
         if ( this.getCharacterUniqueAttributes(index)[holder] !== undefined && this.getCharacterUniqueAttributes(index)[holder].filter(x=>x===undefined).length ) {
            for ( var i = 0; i < this.getCharacterUniqueAttributes(index)[holder].length; ++i ) {
               if ( this.getCharacterUniqueAttributes(index)[holder][i] !== undefined ) {
                  continue;
               }
               this.messenger.sendMessage(this.getCharacterSharedAttributes(index).name + " picks up " + this.getStuffSharedAttributes(stuff).name + " and puts it into slot "+(i+1)+" of "+holder);
               this.sounds.pickupSfx();
               this.getCharacterUniqueAttributes(index)[holder][i] = this.getStuffSharedAttributes(stuff);
               this.getStuffUniqueAttributes(stuff).exists = 0;
               this.reactComponent.refreshWeaponName();
               this.reactComponent.refreshShieldName();
               this.reactComponent.refreshPotionBelt();
               return;
            }
         }
      }
      this.reactComponent.refreshWeaponName();
      this.reactComponent.refreshShieldName();
      this.reactComponent.refreshPotionBelt();
   }

   moveCharacter(index) {
      this.pickupAttempt(index,0);

      if ( this.getCharacterPath(index).length == 0 ) {
         this.resetCharacterPhase(index);
         return; 
      }

      this.refreshCharacterIndex(); 
      this.increaseCharacterPhase(index);

      var ctar = this.getCharacterPath(index)[0];
     
      for ( var i = 0; i < 2; ++i ) {
         var targetDistance = Math.abs(ctar[i] + 0.5 - this.getCharacterPosition(index)[i]);
         if ( targetDistance > this.errorTolerance ) {
            var sgn = Math.sign( ctar[i] + 0.5 - this.getCharacterPosition(index)[i] );
            var posx = this.getCharacterPosition(index);
            var incred = [posx[0],posx[1]];
            incred[i] += (0.5/this.getCharacterSharedAttributes(index).slowness) * sgn;

            if ( this.getCharacterIndexFromPosition(incred) !== undefined
              && this.getCharacterIndexFromPosition(incred) !== index ) { // attack
               this.attack(index, this.getCharacterIndexFromPosition(incred));
               this.setCharacterPath(index,[this.getCharacterPositionFloor(index)]);
               return;
            }
            this.setCharacterPosition(index,incred);
            if ( this.getCharacterPath(index).length > 1 || targetDistance > 0.5 ) { // not adjusting direction after attack
               this.setCharacterFaceDir(index,sgn,i);
            }
            return;
         } else {
            this.setCharacterPositionCoord(index,i,ctar[i] + 0.5);
         }
      }
      this.removeCharacterFirstPathChain(index);
   }

   destroying(index) {
      this.getCharacterUniqueAttributes(index).exists -= this.deathSpeed;
      if ( this.isCharacterFullyDead(index) && this.getCharacterSharedAttributes(index).deathProcedure ) {
         this.getCharacterSharedAttributes(index).deathProcedure();
      }
   }

   kill(index) {
      this.messenger.sendMessage(this.getCharacterSharedAttributes(index).name+" dies");
      this.destroying(index);
   }

   moveCharacters() {
      this.iterateOverCharactersAroundHero((i)=>{ this.isCharacterAlive(i) && (this.moveCharacter(i) || 1) || this.isCharacterFullyDead(i) || this.destroying(i) });
      this.handleWalkSfx();
      this.tryingToUsePotion();
   }

   handleWalkSfx() {
      if ( this.walkSfxCounter < this.walkSfxFrequency) {
         ++this.walkSfxCounter;
      } else {
         this.walkSfxCounter = 0;
         var disti = this.getCharacterPath(0).length ? this.manhattan( this.getCharacterPosition(0), this.getCharacterPath(0)[this.getCharacterPath(0).length-1] ) > 0.1 : 0;
         if( this.getCharacterPhase(0) && disti && this.isCharacterAlive(0) ) {
            this.sounds.walkSfx();
         }
      }
   }

   getWorldName() {
      if ( this.getCharacterPosition(0)[1] < 73 )  return "catacombs";
      if ( this.getCharacterPosition(0)[1] < 145 ) return "iceworld";
      return "hellworld";
   } 

   damage(attacked, value) {
      if ( value <= 0 ) {
         return;
      }
      if ( !this.isCharacterAlive(attacked) ) {
         return;
      }
      this.sounds.ouchFx();
      this.getCharacterUniqueAttributes(attacked).hp -= value;
      if ( this.getCharacterUniqueAttributes(attacked).hp <= 0 ) {
         this.getCharacterUniqueAttributes(attacked).hp = 0;
      }
      if ( this.reactComponent && !attacked ) {
         this.reactComponent.refreshHpValues();
      }
      if ( this.getCharacterUniqueAttributes(attacked).hp <= 0 ) {
         this.kill(attacked);
         return 1;
      }
      this.setCharacterAttackBit(attacked);
      return 0;
   }

   levelingOneLevelUp(i) {
      this.sounds.healSfx();
      ++this.getCharacterSharedAttributes(i).level;
      this.getCharacterSharedAttributes(i).baseHp = this.getBaseHp(this.getCharacterSharedAttributes(i).level);
      this.getCharacterUniqueAttributes(i).hp = this.getCharacterSharedAttributes(i).baseHp;
      this.reactComponent.refreshLevelValues();
      this.reactComponent.refreshHpValues();
      this.messenger.sendMessage("hero levels up");
   }

   getBaseHp(level) { return (this.unitBaseHp + Math.max(level-1,0)*this.unitHpPerLevelIncrease)*2; }

   levelingUp(i) {
      if ( this.getCharacterUniqueAttributes(i).xp !== undefined ) {
         while ( this.minimalLevelXp(this.getCharacterSharedAttributes(i).level+1) <= this.getCharacterUniqueAttributes(i).xp ) {
            this.levelingOneLevelUp(i);
         }
      }
   }

   minimalLevelXp(level) { return (level>1) * 500 * Math.pow(3,level); }

   awardXp(i, attacked) {
      var enemyLevel = this.getCharacterSharedAttributes(attacked).level;
      if ( this.getCharacterUniqueAttributes(i).xp !== undefined ) {
         var rndPart = (0.75+Math.random()/4);
         this.getCharacterUniqueAttributes(i).xp += Math.floor( ((this.minimalLevelXp(enemyLevel+1)-this.minimalLevelXp(enemyLevel)) / this.monsterKillingPerLevelFactor) * rndPart );
         this.reactComponent.refreshXpValues();
         this.levelingUp(i);
      }
   }

   attack(attacker, attacked) {
      var attackValueMax  = this.getCharacterBaseAttack(attacker)  + this.getCharacterHoldedObjectAttribute(attacker,"weapon","value");
      var attackValueMin  = Math.floor(attackValueMax / 2);
      var defenseValueMax = this.getCharacterBaseDefense(attacked) + this.getCharacterHoldedObjectAttribute(attacked,"shield","value");
      var defenseValueMin = Math.floor(defenseValueMax / 2);
      var attackValue     = attackValueMin  + Math.round( (attackValueMax - attackValueMin)*Math.random() );
      var defenseValue    = defenseValueMin + Math.round( (defenseValueMax-defenseValueMin)*Math.random() );
      var damageValue     = Math.max(attackValue - defenseValue,0);
      var pointsText = damageValue > 1 ? " points" : " point";
      this.messenger.sendMessage(this.getCharacterSharedAttributes(attacker).name + " attacks " + this.getCharacterSharedAttributes(attacked).name + " and " + (damageValue <= 0 ? "misses" : "damages " + damageValue + pointsText) + " ("+attackValue+"-"+defenseValue+")");
      if ( this.damage(attacked,damageValue) ) {
         this.awardXp(attacker, attacked);
      }
   }

   giveInstructionsToNPCsWithAI(fps) {
      var aiFrequencyDecreaseRatio = 5; // AI runs in every (1 / fps * aiFrequenceDecreasingRatio) second
      if ( this.aiCounter < aiFrequencyDecreaseRatio ) {
         ++this.aiCounter;
      } else {
         this.aiCounter = 0;
         this.refreshCharacterIndex();
         this.iterateOverCharactersAroundHero(
            (i)=>{ i != 0
                && this.isCharacterAlive(i)
                && this.isCharacterAlive(0) 
                && this.manhattan(this.getCharacterPosition(0), this.getCharacterPosition(i)) <= this.getCharacterSharedAttributes(i).range
                && this.isCharacterAtCellCenter(i)
                && this.setCharacterPathWithBfs(i, this.getCharacterPositionFloorObj(0));
                   });
      }
   }

   manhattan(p1,p2) {
      return Math.abs(p1[0]-p2[0]) + Math.abs(p1[1]-p2[1]);
   }

   isMapCellWalkable(y,x) {
      return this.getMapCell(y,x) <= 6;
   }
};

class DrawCanvas {
   fromChar(chr,shift) {
      var retval = chr.charCodeAt(0);
      if ( chr == "{" ) return 39-shift;
      if ( chr == "}" ) return 92-shift;
      return retval -= shift;
   }

   stringDecoder(period,shift,code) {
      var [ptr1,counter,retval,row] = [0,0,[],[]];
      while (ptr1 < code.length) {
         var tuple = [this.fromChar(code[ptr1],shift),this.fromChar(code[ptr1+1],shift),5];
         if ( code[ptr1+2] == '|' ) tuple[2] = 12;
         if ( code[ptr1+2] == '~' ) tuple[2] = 15;
         ptr1+=2+(tuple[2]!=5);
         row.push(tuple);
         ++counter;
         if ( counter == period ) {
            retval.push(row);
            row = [];
            counter = 0;
         }
      }
      return retval;
   }

   constructor(reactComponent, gameWorld) {
      this.reactComponent = reactComponent;
      this.gameWorld = gameWorld;
      this.characterBodyDrawData = this.stringDecoder(23,30,'2;1@0F/L0R0W0}1b1h1o/*~1;|0M|9>:E:M:U8}4Z5a5i6p6v3<3B3J0Q+U1X1^.c7h?j/)~2;|1L|:>;F<M<U:}5Y5`5g6o7v6=9B:I;N:U1V-}(c+g,l/(~2;|3I|5=4D3K1R-W6V7_8g;o?v;:=A>H>N=T1W-})b%i!n/)~2;|1K|4=.Q1J3C*U7W9_<hDmKr;>=C>J@O?U1X,](b)i*o.-~2?|2L|3?3G3N/S*T7X8_9f>kEo7?:F:L:S:Z2]1X0d3j4p.*~1=|2K|6?5F3L2R-X6W3]2c9g?i2;2C2K.P+T5V7]8c:i;n/{~2;|3J|8<9D;L;T:Z4U0Z.`0f2k3<.L2G3?+Q8Y:`=eCiIl.)~1<|2L|;<=B@H@O@V3Y/a*h%p w2?1A1H.N*Q6Y6`8g>jEk/-~1>|2L|8@=C@LASAY1Y-`(h)o*u/;-A+H*O*V/U/}/c0k1r/+~1;|0I|=>>F>N>V<]7V7]8f9n;v0;/A.G-N,U1U1}0d7c=a0*~2:|1J|=:?AAI@Q>X8U8}8c:k<r291?2E1J1P:S:Y:b=h@o0(~29|3F|;<;B:I8Q5X2R.Y*`-e2j4:7?8E;H=M3T.},c)k&r0)~1:|2I|<<;C8J5Q1V9T:Y<_@dFh2=2A4E9H=K2V-})c)j(r0-~2=|2J|<?:F7M4R0W8U:}<bAeFg2;2A2F3K3P8P7W7^;a@c/*~3;|3G|<;=C=K<R;Y2Q2X2_3f7m0:/@.G,L)R2Q1V3^7c9j0{~29|2E|=:?@AFBMBS8P5V2[2c2j/;/@,F*L)R2T3Y5^:d?f0)~2;|2H|><@ACHEMFT7}4e9U1n/x/>.D+I)O{T2V1^2e8e=e/-~2=|2J|==?CBHDODV7^9V3d5u4m.=,D+K,R-X2X2_2f2n3v1+~3<|3L|?=ACBKAR@X;X;_;f:n:u.;-B-I,P-W3U2]2e5b5^1*~3:|3I|?:@A@H@P?W:U;};b:i9p/:.@.E/K1P:S:f:_;Y:l1(~39|4G|>:@@@F?N=T2Y3S0^1d3i/:/@0F1L2Q;S=U<X:}8_2)~4:|4H|?:?A?H=P8W3}3T3l3d3t/=.B/H/M0S:V;_<[:b8e1-~4=|4J|>=@D@K@S<Y2W2d3j2]3p.;-B,J-P-W3T2Z2b3i3p2+~3;|3H|?;@B@I@P?W:T9a;d;[9`>:??>D>J<O3S2_3Y3e3k1(~39|3G|/9.?-F.M0T:S<X=^<d9i=9<I>C>>=N3S1V1Y3[5^2)~39|3G|0:.@/H0O5W:S;[;c;k:t?=>C?I>O<S3W3Z2^3b4e1-~3=|3K|/=-D-L.R1X:W;];e;k:q@9B@CHDODV7U6^6f5n4v4*~6;|7I|1>0F/M1T2[?T?[?b?j=q;;;B;H<M<R<R<Y<`;g8n4*~6:|5G|2:1A0I2Q3X7R7Y6`2c,d>:?@@FBLDQ<Q=W<}7c4i4(~59|5F|2:/?.E,M+T9V7P<}=d;j?;@@BFCKFP<T;Z;a5d/g4)~5:|5I|0<.B,H*M)S5U7];i<p?x?=@CBIDNGS=W=^<e7e1f4-~5=|6L|1>.C,I*O)U5Y7^;d:m9u=<>B@H@NBT=U=}=d8d2`4*~5;|6J|2</C.J.Q/W6U6]5d4k2r;9<><C<J=Q5R4Y4a1i,p4(~49|5F|3:4A3I6Q9W=QAYE`Ae<k=9:=9C5H2M?S@ZBbEiHr5)~6;|6H|3<4B6I:O=U5Q4W4].c(i<=:A9D5H1K>SAZDaFjFq4-~6>|6K|3?5D6L:Q=U6T4Z3a.e{g9<;A=F=L<R;W;];d:i9o2*~3=|4L|2?0F0O2U3]8X8_6f5n4v4>2C0J0R1Y8W9]:c8j6p2*~2<|2K|5>6D8K:R>W5X7]:c4g-j8:8A8I<N@S7S5[3b1h/n2(~3;|3G|3<2C1K1R1Y5S:X=_<f9k8<8A8E;K?P9U2^.e)i!l3)~3;|2J|0<.A,G*O+U4W;^AfFoKw9>8C9H<NAQ:U6]5e.i&k3-~3?|3L|2@.E,K*R*Z5W<^BfBnAv8<9B8I;P?U9W;]<c4g,j2*~3=|3L|3<0D/K/S1[6X6_6g5n4v4;3A1G1O1U9T?[CaBg?l2(~2;|3I|7=7D9K;R>W5V5_3i0p,v2:.?,F-L-R;U>[AaEgJn2)~39|3I|8>8C:J<PAT5U3_.h{n s2>/B,G,M+S;W?}CaBh@o2-~2?|3L|8B9G9K;P@T5W4^1e,j%o,<+C+J,P-V2U2}1c0j/q1+~1<|2K|=>?D@M@T@}:W:]:f:n9v-;-A,G,M-T1S0Z0a/i.p1)~1;|1H|<<<C<J=Q?Y8T:[:a6g2m.9/>3E4J4N7S<Y@]=e;k1(~1:|1G|;=9D9K9R9Y1S1Z/a-i+p/:0?2D4I7L0U.],e{l"t1)~1;|0H|:>7E6L5T5[9U>}BbEgJm/<0A2D4H8M1W0^.f)k$p2-~1=|1K|:A7H5N4V4]9X<]AaBiCp-:,@-E-K/R6S8]7e7m6u1*~1;|/H|:?9F8M7U6}/S1[3b.f)h/:-@,F,M,S0T4X9}:a;e1(~2:|1H|<<=B=I>P?V7U7_6g4o3v/;,A*G*N*U0R4W8}<a@e1(~1;|1H|<==C>H@OAT8T4`3j/p+x/>,C*H)O(U1S3Z6a6g6l1-~2>|1K|:@<D>I?NBR7T8[9b5g0m.=-D+K,R,Y2W2_2g2n3u1+~3;|3L|?<ACAKARAY;W;_;g;n:u.:-A-I-P-W3U2}1d3l2t1)~39|3H|?;@A@I@W@P:U;}<c:f8j.9.>/E0K2Q:S;W;};_;c2(~39|3G|>9??@G?N?U3S2}1e2m2u0:0@0E2J3O9R:U:X:};^2)~39|3G|=:>A>H>N=T1x3R2[2e2n/>/C.H0M1R:U;Y;];a;d2-~4=|3J|>>@D?K?R>Y3U2[1a3g4m.;-B,J-Q-W2V2^1e3h4j2)~3:|3K|>;?B@I@P@V;V;];c:k:t?:???D>J<O2R3V2Z2_2b1(~39|3G|0:.A-H.O/V:R;Z;c;m<u=;=?<D<G;L4S3V3Y2]2_2)~3H|3:|/;/B/H0N0T:T;};e<o<x>=?D?J>O<T3U2Y2]2a1e2-~3>|4K|0=.D.K.S/Y:V<[=a;g:m>;?B@I@N?U:U:[;b<i=p1)~4<|3J|0=-D,L,S,[2W2^2f3m4u?9@?@G?M=R=U:]:b>fCi1*~6:|6I|2?3E4M5T5[7U5]5e6m6u>;@AAH@N@T;T7Y5}2_2e1(~5:|5G|0</B/H/O-U5T5}6f8n:v><@ABHCOAU:S6Y3]/a+e1)~4;|4H|0=/B.I-O*T5S7]9g=p@x2@0D/I-M*R;V9Z6`6g6m1,~5>|4J|>>ACBICODV5U4[4b8g=m?;?@@G@M@S;V;}<b=i>p1)~5<|5J|1=0C0I/P.W4V2}3b7g:m>9>><D;J:M6T0Y,^.d1j1{~59|5G|1=3C3J4Q4X<T<Z<`?hAp>9>?=E=J<N3T0Z,a{g"m1)~5;|5I|1>4D5L7T8[<T>]@eDmIs=;>B=J;O<R;X=^?dDjHo1-~5?|5N|2A5G6M8U8}4X0^,b*i)p' );
      this.weaponDrawData = this.stringDecoder(6,35,'4W$R7#A#K#>a$#-#7#0Z#Q@`?Z-V7#A#K#1}BY2T6#A#K#/[EY5W7#A#K#0Y?_0Z7#@#J#2]0Z$S7#A#K#>_0U$J7#A#K#E[/V#J7#A#K#E^##-#7#/}#YAb##-#7#0Z{MC}5U{Q7#A#K#:]BR0T7#A#K#7[BQ3T7#A#K#5]7V(T7#A#K#@^&#-#7#/W#OFW$#+#7#-W$JLY$#,#7#,Y%KJ[##-#7#2^-WU###-#6#2}2PF[6V.Y7#A#K#BW5W-X7#A#K#=}##-#7#5Y-]A^%#-#7#3[*VD}##-#BV5Y6RU###-#AU:}=RU###-#AY5^9SU###-#J[7_HXU###-#BU8]GUU###-#IV0YBZU###-#KV.Y=ZU###-#KW.[<ZU###-#GZ4}BZU###-#AV=}JSU###-#6RBZLQU###-#6QCZNOU###-#AX7aH[U###-#7]C}MTU###-#EW6^HZU###-#ET/ZA[U###-#FW/_@]U###-#DZ6`F}U###-#5ZC}PRU###-#2WFYMNU###-#0XEYNPU###-#2[E`PVU###-#1XE]JOU###-#;P?^JYU###-#=U:`H[U###-#=V9bF_U###-#3Y;`EYU###-#0XD[KQU###-#/YGYNMU###-#,ZGWNJU#F^FQ0^A#K#U#E[EU1}A#K#U#DZBN5VA#K#U#AYCN9YA#K#U#C^ET6YA#K#U#E[FQ2}A#K#U#BS:L3[A#K#V#?T;N4YA#K#U#AX=R3_A#K#U#DZ4P7#A#K#1_?Z0Q7#A#K#9`DX6Q7#A#K#2ZFZ6T7#A#K#/YH[8V7#A#K#.VEW5P7#A#K#2}=V0L7#A#K#8^>V.L6#A#K#<_=W/N7#A#K#<a##-#7#A#K#U###-#7#A#K#U#');
      var drawDescriptorForWarrior = [[0],[0,1],[1],[1,2],[2],[2,3],[3],[3,4],[4],
                                      [5],[5,6],[6],[6,7],[7],[7,8],[8],[8,9],[9],
                                      [10],[11],[11,12],[12],
                                      [13],[13,14],[14],[14,15],[15],[15,16],[16],[16,17],[17],
                                      [18],[18,19],[19],[19,20],[20],[20,21],[21],[21,22],[22]];
      var drawDescriptorForWarriorWithWeapon = [[23],[23,24,0.75,0.25],[23,24],[23,24,0.25,0.75],[24],[23,24,-0.25,1.25],[23,24,-0.5,1.5],[23,24,-0.75,1.75],[23,24,-1,2],
                                                [0],[0,1],[1],[1,2],[2],[2,3],[3],[3,4],[4],
                                                [5],[5,6],[6],[6,7],[7],[7,8],[8],[8,9],[9],
                                                [10],[11],[11,12],[12],
                                                [13],[13,14],[14],[14,15],[15],[15,16],[16],[16,17],[17],
                                                [18],[18,19],[19],[19,20],[20],[20,21],[21],[21,22],[22],
                                                [26],[26,27,0.75,0.25],[26,27],[26,27,0.25,0.75],[27],[26,27,-0.75,1.75],[26,27,-0.5,1.5],[26,27,-0.25,1.25],[26,27,-1,2]];

      var drawDescriptorForWarriorWithShield = [[25,25,0.5,0.5,10],
                                                [0],[0,1],[1],[1,2],[2],[2,3],[3],[3,4],[4],
                                                [5],[5,6],[6],[6,7],[7],[7,8],[8],[8,9],[9],
                                                [10],[11],[11,12],[12],
                                                [13],[13,14],[14],[14,15],[15],[15,16],[16],[16,17],[17],
                                                [18],[18,19],[19],[19,20],[20],[20,21],[21],[21,22],[22],
                                                [28,28,0.5,0.5,10]];

      var drawDescriptorForWarriorWithWeaponAndShield =
            [[23],[23,24,0.75,0.25],[23,24],[23,24,0.25,0.75],[24],[23,24,-0.25,1.25],[23,24,-0.5,1.5],[23,24,-0.75,1.75],[23,24,-1,2],[25,25,0.5,0.5,10],
             [0],[0,1],[1],[1,2],[2],[2,3],[3],[3,4],[4],
             [5],[5,6],[6],[6,7],[7],[7,8],[8],[8,9],[9],
             [10],[11],[11,12],[12],
             [13],[13,14],[14],[14,15],[15],[15,16],[16],[16,17],[17],
             [18],[18,19],[19],[19,20],[20],[20,21],[21],[21,22],[22],
             [26],[26,27,0.75,0.25],[26,27],[26,27,0.25,0.75],[27],[26,27,-0.75,1.75],[26,27,-0.5,1.5],[26,27,-0.25,1.25],[26,27,-1,2],[28,28,0.5,0.5,10]];

      this.drawDescriptors = [drawDescriptorForWarrior,drawDescriptorForWarriorWithWeapon,drawDescriptorForWarriorWithShield, drawDescriptorForWarriorWithWeaponAndShield];

      this.descriptorValueToColor=[2,2,2,2,2,
                                   3,3,3,3,3,
                                   0,1,1,
                                   4,4,4,4,4,
                                   5,5,5,5,5,
                                   6,6,7,6,6,7];

      this.floorColors = ["#AAAAAA","white","firebrick","blue","magenta","#AAAAAA"];
      this.wallColors  = ["gray","#CDCDCD","darkred","gray","#CDCDCD","#835C3B"];

      this.tileSize = 35;
      this.errorTolerance = 0.01;

      this.screenConstantsAreSet = false;
   }

   refreshContext() {
      if ( this.reactComponent.canvas === undefined ) {
         return 0;
      }
      this.context = this.reactComponent.canvas.getContext('2d');
      return 1;
   }

   refreshScreenConstants(force=false) {
      if ( this.screenConstantsAreSet && !force ) {
         return 1;
      }
      this.screenConstantsAreSet = false;
      if ( this.reactComponent.canvas === undefined ) {
         return 0;
      }
      this.screenWidth  = this.reactComponent.canvas.width  = window.innerWidth;
      this.screenHeight = this.reactComponent.canvas.height = Math.round(window.innerHeight * 0.70);
      var minDimension  = Math.min(window.innerWidth, window.innerHeight);
      this.tileSize     = Math.max(Math.round(Math.round(minDimension/20)/8.0)*8,16);
      this.leftOffset   = 0;

      var mapRadiusX = this.screenWidth/4/this.tileSize/Math.sqrt(3);
      var mapRadiusY = this.screenHeight/4/this.tileSize;
      this.mapRadius = Math.ceil(2 * Math.max(mapRadiusX,mapRadiusY));
      this.screenConstantsAreSet = true;
      return 1;
   }

   drawBox(boxX,boxY,boxSize,boxSize2,boxColor, exists) {
      this.context.beginPath();
      this.context.rect(boxX, boxY, Math.round(boxSize*exists), Math.round(boxSize2*exists));
      this.context.fillStyle = boxColor;
      this.context.fill();
   }

   drawRectangle(boxX,boxY,boxSize1,boxSize2,boxColor) {
      this.context.beginPath();
      this.context.rect(boxX, boxY, boxSize1, boxSize2);
      this.context.fillStyle = boxColor;
      this.context.fill();
   }

   drawCircle( pnt, radius, strokeColor, fillColor ) {
      this.context.strokeStyle = strokeColor;
      this.context.fillStyle   = fillColor;
      this.context.beginPath();
      this.context.arc( pnt.x, pnt.y, radius, 0, 2 * Math.PI, false );
      this.context.closePath();
      this.context.lineWidth = 2;
      this.context.stroke();
      this.context.fill();
   }

   drawBoxExtended(ux,uy,i,ind1,ind2,w1,w2,rad) {
      var phaseKey = this.gameWorld.getCharacterAnimationKey(i);
      var rimage = this.characterBodyDrawData[phaseKey];
      var wimage = this.weaponDrawData[phaseKey];
      var scale = this.gameWorld.getCharacterSharedAttributes(i).scale;
      var characterColors = this.gameWorld.getCharacterSharedAttributes(i).coloring;
      if ( this.gameWorld.getCharacterAttackBit(i) ) { // drawing in red because of damage
         characterColors = characterColors.map(x=>x?"red":"");
      }
      var exists      = this.gameWorld.getCharacterUniqueAttributes(i).exists;
      var shieldrad   = this.gameWorld.getCharacterHoldedObjectAttribute(i,"shield","size");
      var weaponcolor = this.gameWorld.getCharacterHoldedObjectAttribute(i,"weapon","color");

      var simage = rimage;
      var cind = ind1;
      if ( w1 === undefined ) {
         w1 = 0.5;
      }
      if ( w2 === undefined ) {
         w2 = 0.5;
      }
      var isShield = ((ind1 == 25) || (ind1 == 28))&&(shieldrad > this.errorTolerance);
      if ( ind1 > 22 ) {
         simage = wimage;
         ind1 -= 23;
         if ( ind2 !== undefined ) {
            ind2 -= 23;
         }
         if ( simage[ind1][1] < 3 ) {
            return;
         }
      }
      var colorIndex = this.descriptorValueToColor[cind];
      var color = characterColors[colorIndex];
      if ( color === "" ) {
         return;
      }
      if ( colorIndex > 5 ) {
         if ( colorIndex === 6 ) {
            color = weaponcolor;
         }
         if ( colorIndex === 7 ) {
            color = "black";
         }
      }

      var percentage = this.tileSize / 50;
      if ( ind2 === undefined ) {
         this.drawBox(ux+simage[ind1][0]*percentage,
                      uy+simage[ind1][1]*percentage*scale,
                      simage[ind1][2]*percentage,
                      simage[ind1][2]*percentage,
                      color,
                      exists);
      } else {
         var orad = (rad===undefined?simage[ind1][2]:rad*2)*percentage;
         this.drawBox(ux+(Math.floor(simage[ind1][0]*w1+simage[ind2][0]*w2)-(rad===undefined?0:rad))*percentage,
                      uy+(Math.floor(simage[ind1][1]*w1+simage[ind2][1]*w2)-(rad===undefined?0:rad))*percentage*scale-orad*(isShield?shieldrad/2-0.5:0),
                      orad,
                      orad*(isShield?shieldrad:1),
                      color,
                      exists);
      }
   }

   drawCharacter(y,x,i) {
      var drawDescriptor = this.drawDescriptors[this.gameWorld.getCharacterAnimationWeaponShieldValue(i)];
      var scale = this.gameWorld.getCharacterSharedAttributes(i).scale;
      var cx = (x + y) * Math.sqrt(3) * this.tileSize + this.screenWidth / 2;
      var cy = (x - y) * this.tileSize + this.screenHeight / 2;
      var percentage = this.tileSize / 50;
      var ymax = 100 * percentage * scale;
      var xmax = 54  * percentage;
      var ux = Math.floor(cx - xmax/2);
      var uy = Math.floor(cy - ymax + ymax * percentage * 0.1);
      if  ( this.gameWorld.getCharacterSharedAttributes(i).transparency ) {
         this.context.globalAlpha = this.gameWorld.getCharacterSharedAttributes(i).transparency;
      }
      drawDescriptor.map(box=>this.drawBoxExtended(ux,uy,i,...box));
      this.context.globalAlpha = 1.0;
      this.gameWorld.eraseCharacterAttackBit(i);
   }

   scaledValue(value) { return Math.round((value/35)*this.tileSize); }

   getTileCenter(y,x) {
      return [(x + y) * Math.sqrt(3) * this.tileSize + this.screenWidth / 2,
              (x - y) * this.tileSize + this.screenHeight / 2];
   }

   getFloorTile(y,x,obi) {
      var [px,py] = this.getTileCenter(y,x);
      obi.ps = [{x:px,y:py-this.tileSize},{x:px + Math.sqrt(3) * this.tileSize,y:py},{x:px,y:py+this.tileSize},{x:px - Math.sqrt(3) * this.tileSize,y:py}];
      return obi;
   }

   getFloorTileScale(y,x,obi,scale) {
      var px = (x + y) * Math.sqrt(3) * this.tileSize + this.screenWidth / 2;
      var py = (x - y) * this.tileSize + this.screenHeight / 2;
      obi.ps = [{x:px,y:py-this.tileSize*scale},{x:px + Math.sqrt(3) * this.tileSize*scale,y:py},{x:px,y:py+this.tileSize*scale},{x:px - Math.sqrt(3) * this.tileSize*scale,y:py}];
      return obi;
   }

   drawCell(y,x,cy,cx,oy,ox) {
      var color = this.wallColors[ (this.gameWorld.getMapCell(cy+y,cx+x) - 1) % this.wallColors.length ];
      if ( !this.gameWorld.getMapCell(cy+y,cx+x-1) ) {
         this.drawWall(-y+oy,x-ox,0,color);
      }
      if ( !this.gameWorld.getMapCell(cy+y-1,cx+x) ) {
         this.drawWall(-y+oy,x-ox,1,color);
      }

      var mapval = this.gameWorld.getMapCell(cy+y,cx+x);
      var speciality = Math.floor((mapval-1) / this.wallColors.length);
      var sworld = (mapval-1) % this.wallColors.length;

      {
         var i = this.gameWorld.getStuffIndexFromPosition([cy+y,cx+x]);
         if ( i !== undefined ) {
            var attribs = this.gameWorld.getStuffSharedAttributes(i);
            if ( this.gameWorld.getStuffUniqueAttributes(i) !== undefined && this.gameWorld.getStuffUniqueAttributes(i).exists ) {
               var [px,py] = this.getTileCenter(-y+oy,x-ox);
               this.drawRectangle(Math.round(px-this.scaledValue(attribs.width/2)),
                                  Math.round(py-this.scaledValue(attribs.height/2)),
                                  this.scaledValue(attribs.width),
                                  this.scaledValue(attribs.height),
                                  attribs.color);
            }
         }
      }

      if ( speciality == 1 ) {
         if ( sworld == 1 ) {
            // christmas tree
            var [px,py] = this.getTileCenter(-y+oy,x-ox);
            this.context.fillStyle = SPECIAL_COLORS.TABLEBROWN;
            this.contextPathForObjectDraw({ps:[{x:px-this.scaledValue(3),y:py},
                                          {x:px+this.scaledValue(3),y:py},
                                          {x:px+this.scaledValue(3),y:py-this.scaledValue(10)},
                                          {x:px-this.scaledValue(3),y:py-this.scaledValue(10)}]});
            this.context.fill();
            this.context.fillStyle = 'green';
            this.contextPathForObjectDraw({ps:[{x:px-this.scaledValue(30),y:py-this.scaledValue(10)},
                                          {x:px+this.scaledValue(30),y:py-this.scaledValue(10)},
                                          {x:px                ,y:py-this.scaledValue(100)}]});
            this.context.fill();
            this.drawCircle({x:px+this.scaledValue(12),y:py-this.scaledValue(30)},this.scaledValue(2),'yellow','yellow');
            this.drawCircle({x:px-this.scaledValue(8), y:py-this.scaledValue(45)},this.scaledValue(2),'yellow','yellow');
            this.drawCircle({x:px+this.scaledValue(8), y:py-this.scaledValue(52)},this.scaledValue(2),'magenta','magenta');
            this.drawCircle({x:px-this.scaledValue(1), y:py-this.scaledValue(65)},this.scaledValue(2),'yellow','yellow');
         } else {
            // table
            var tile = this.getFloorTile(-y+oy+0.5,x-ox-0.5,{x:x+cx,y:y+cy});
            var tableColor = !sworld ? SPECIAL_COLORS.TABLEBROWN : SPECIAL_COLORS.STEEL;
            this.drawRectangle(tile.ps[1].x-this.scaledValue(5),tile.ps[1].y,                    this.scaledValue(5),this.scaledValue(35),tableColor);
            this.drawRectangle(tile.ps[2].x-this.scaledValue(2),tile.ps[2].y-this.scaledValue(2),this.scaledValue(5),this.scaledValue(35),tableColor);
            this.drawRectangle(tile.ps[3].x                    ,tile.ps[3].y                    ,this.scaledValue(5),this.scaledValue(35),tableColor);
            this.drawFloor(tile,tableColor);
         }
      }

      if ( speciality == 2 ) {
         if ( sworld == 1 ) {
            // snowman
            var [px,py] = this.getTileCenter(-y+oy,x-ox);
            this.drawCircle({x:px,                    y:py-this.scaledValue(20)},this.scaledValue(20),'black','white');
            this.drawCircle({x:px,                    y:py-this.scaledValue(37)},this.scaledValue(15),'black','white');
            this.drawCircle({x:px,                    y:py-this.scaledValue(53)},this.scaledValue(10),'black','white');
            this.drawCircle({x:px-this.scaledValue(4),y:py-this.scaledValue(55)},this.scaledValue(1) ,'black','black');
            this.drawCircle({x:px+this.scaledValue(4),y:py-this.scaledValue(55)},this.scaledValue(1) ,'black','black');
            this.drawCircle({x:px,                    y:py-this.scaledValue(28)},this.scaledValue(1) ,'black','black');
            this.drawCircle({x:px,                    y:py-this.scaledValue(33)},this.scaledValue(1) ,'black','black');
            this.drawCircle({x:px,                    y:py-this.scaledValue(38)},this.scaledValue(1) ,'black','black');
         } else {
            // chair
            var tile = this.getFloorTileScale(-y+oy+0.20,x-ox-0.20,{x:x+cx,y:y+cy},0.5);
            var chairColor = sworld == 2 ? 'silver' : SPECIAL_COLORS.CHAIRBROWN; 
            this.drawRectangle(tile.ps[1].x-this.scaledValue(5),tile.ps[1].y                    ,this.scaledValue(5),this.scaledValue(18),chairColor);
            this.drawRectangle(tile.ps[2].x-this.scaledValue(2),tile.ps[2].y-this.scaledValue(2),this.scaledValue(5),this.scaledValue(18),chairColor);
            this.drawRectangle(tile.ps[3].x                    ,tile.ps[3].y                    ,this.scaledValue(5),this.scaledValue(18),chairColor);
            this.drawFloor(tile,chairColor);
            
            this.drawFloor({ps:[tile.ps[0],tile.ps[3],{x:tile.ps[3].x,y:tile.ps[3].y-this.scaledValue(35)},{x:tile.ps[0].x,y:tile.ps[0].y-this.scaledValue(35)}]}, chairColor);
         }
      }

      var i = this.gameWorld.getCharacterIndexFromPosition([cy+y,cx+x]);
      if ( i !== undefined ) {
         var pos = this.gameWorld.getCharacterPosition(i);
         this.drawCharacter((oy+cy+0.5)-(pos[0]),-(ox+cx+0.5)+(pos[1]),i);
      }

      if ( !this.gameWorld.getMapCell(cy+y+1,cx+x) ) {
         this.drawWall(-y+oy,x-ox,2,color);
      }
      if ( !this.gameWorld.getMapCell(cy+y,cx+x+1) ) {
         this.drawWall(-y+oy,x-ox,3,color);
      }
   }

   drawCellFloor(y,x,cy,cx,oy,ox,tiles) {
      var color = this.floorColors[ (this.gameWorld.getMapCell(cy+y,cx+x) - 1) % this.floorColors.length ];
      var tile  = this.getFloorTile(-y+oy,x-ox,{x:x+cx,y:y+cy});
      this.drawFloor(tile, color, this.gameWorld.getMapCell(cy+y+1,cx+x)&&this.gameWorld.getMapCell(cy+y,cx+x+1));

      tiles.push(tile);
   }

   contextPathForObjectDraw(obj) {
      this.context.beginPath();
      for ( var i = 0; i < obj.ps.length; ++i ) {
         ( i == 0 ? this.context.moveTo( Math.round(obj.ps[i].x), Math.round(obj.ps[i].y) ) : this.context.lineTo( Math.round(obj.ps[i].x), Math.round(obj.ps[i].y) ) );
      }
      this.context.closePath();
   }

   drawFloor(tile, color,tick) {
      this.context.fillStyle = color;
      this.context.strokeStyle = color;
      this.contextPathForObjectDraw(tile);
      this.context.lineWidth = tick ? 2 : 1;
      this.context.fill();
      this.context.stroke();
   }

   drawTile(tile,color) {
      this.context.strokeStyle = color;
      this.context.lineWidth = 1;
      this.contextPathForObjectDraw(tile);
      this.context.stroke();
   }

   drawForeground( camCenter, visibleTiles ) {
      var cy = Math.floor(camCenter[0]);
      var cx = Math.floor(camCenter[1]);
      var oy = camCenter[0] - cy - 0.5;
      var ox = camCenter[1] - cx - 0.5;

      var cellsy = [];
      var cellsx = [];

      for ( var y = -this.mapRadius; y < this.mapRadius; ++y ) {
         for ( var x = -this.mapRadius; x < this.mapRadius; ++x ) {
            if ( this.isMapCellVisible(y,x,cy,cx,oy,ox) 
                 || this.isMapCellVisible(y,x,cy,cx,oy,ox,0,0) 
                 || this.isMapCellVisible(y,x,cy,cx,oy,ox,0,1) 
                 || this.isMapCellVisible(y,x,cy,cx,oy,ox,1,0) 
                 || this.isMapCellVisible(y,x,cy,cx,oy,ox,1,1) )
            {
               if ( this.gameWorld.getMapCell(cy+y,cx+x) ) {
                  cellsy.push(y);
                  cellsx.push(x);
               }
            }
         }
      }

      this.gameWorld.refreshStuffIndex();

      for ( var i = 0; i < cellsx.length; ++i ) {
         this.drawCellFloor(cellsy[i],cellsx[i],cy,cx,oy,ox,visibleTiles);
      }

      for ( var i = 0; i < cellsx.length; ++i ) {
         this.drawCell(cellsy[i],cellsx[i],cy,cx,oy,ox);
      }
   }

   drawWall(y,x,num, color) {
      var px = (x + y) * Math.sqrt(3) * this.tileSize + this.screenWidth / 2;
      var py = (x - y) * this.tileSize + this.screenHeight / 2;

      var bit1 = (num % 2) * 2 - 1;
      var bit2 = (num >= 2) * 2 - 1;

      if ( num < 2 ) {
         this.context.globalAlpha = 1.0;
         this.context.fillStyle   = color;
      } else {
         this.context.globalAlpha = 0.75;
         this.context.fillStyle   = "#000000";
      }
      var sy = 1;
      this.contextPathForObjectDraw( {ps:[{x:px,y:py + bit2 * this.tileSize+sy},{x:px + bit1 * Math.sqrt(3) * this.tileSize, y:py+sy},{x:px + bit1 * Math.sqrt(3) * this.tileSize, y:py - 2 * this.tileSize+sy},{x:px, y:py + bit2 * this.tileSize - 2 * this.tileSize+sy}]} );
      this.context.fill();
      this.context.globalAlpha = 1.0;
   }

   isMapCellVisible(y,x,cy,cx,oy,ox,sx=0.5+ox,sy=0.5+oy) {
      var dirY  = y - oy;
      var dirX  = x - ox;
      var dirL  = Math.hypot(dirX,dirY);
      dirY /= dirL;
      dirX /= dirL;

      var celly   = cy;
      var cellx   = cx;

      var dist    = 0;
      var arrived = 0;
      var limit   = 50;
      var err     = 1e-6;

      while ( limit && this.gameWorld.getMapCell( celly, cellx ) && !( celly == cy + y && cellx == cx + x ) ) {
         --limit;
         var jump  = Math.min( Math.max( ( 1 - sx ) / dirX, -sx / dirX ),
                               Math.max( ( 1 - sy ) / dirY, -sy / dirY ) );
         dist += jump;
         sx = sx + dirX * jump;
         sy = sy + dirY * jump;
         var pcellx = cellx;
         var pcelly = celly;
         if ( Math.abs(sx) < err && dirX < 0) {
            sx = 1;
            cellx -= 1;
            arrived = 1;
         } else if ( Math.abs(1-sx) < err && dirX > 0 ) {
            sx = 0;
            cellx += 1;
            arrived = 2;
         }
         if ( Math.abs(sy) < err && dirY < 0 ) {
            sy = 1;
            celly -= 1;
            arrived = 3;
         } else if ( Math.abs(1-sy) < err && dirY > 0 ) {
            sy = 0;
            celly += 1;
            arrived = 4;
         }
         if ( pcellx != cellx && pcelly != celly ) {
            if ( !this.gameWorld.getMapCell( celly, pcellx ) && !this.gameWorld.getMapCell( pcelly, cellx ) ) {
               [celly,cellx] = [pcelly,pcellx];
               break;
            }
         }
      }

      return ( celly == cy + y && cellx == cx + x );
   }
   
   drawBackground() {
      this.context.fillStyle = "black";
      this.context.fillRect(0,0,this.screenWidth,this.screenHeight);
   }

   draw(mouseState, retobj) {
      if ( !this.refreshContext() || !this.refreshScreenConstants() ) {
         retobj.failed = true;
         return;
      }

      var cursorX = mouseState.cursorX - this.leftOffset;
      var cursorY = mouseState.cursorY;
      var visibleTiles = [];
      this.gameWorld.refreshCharacterIndex();
      this.drawBackground();
      this.drawForeground(this.gameWorld.getCharacterPosition(0), visibleTiles);
      var currentTarget = this.getCursorsTile(visibleTiles,cursorX,cursorY);
      if ( this.gameWorld.isCharacterAlive(0) && currentTarget !== undefined && this.gameWorld.isMapCellWalkable(currentTarget.y,currentTarget.x) ) {
         var characterIndexOnSelectedCell = this.gameWorld.getCharacterIndexFromPosition([currentTarget.y,currentTarget.x])
         this.drawTile(currentTarget, characterIndexOnSelectedCell === undefined ? "yellow" : (characterIndexOnSelectedCell === 0 ? "blue" : "red"));
         return currentTarget;
      }
   }

   getPointSide(p1,p2,p3) {
      return Math.sign( (p1.y-p2.y) * (p3.x-p1.x) + (p2.x-p1.x) * (p3.y-p1.y) );
   }

   isPointInTriangle(p1,p2,p3,pt) {
      var retval = ( this.getPointSide(p1,p2,p3) * this.getPointSide(p1,p2,pt) >= 0 )
                && ( this.getPointSide(p2,p3,p1) * this.getPointSide(p2,p3,pt) >= 0 )
                && ( this.getPointSide(p3,p1,p2) * this.getPointSide(p3,p1,pt) >= 0 );
      return retval;
   }

   getCursorsTile(tiles, cx, cy) {
      for ( var i = 0; i < tiles.length; ++i ) {
         if ( this.isPointInTriangle( tiles[i].ps[0], tiles[i].ps[1], tiles[i].ps[3], {x:cx,y:cy} )
           || this.isPointInTriangle( tiles[i].ps[1], tiles[i].ps[2], tiles[i].ps[3], {x:cx,y:cy} ) ) {
            return tiles[i];
         }
      }
   }
}


class DiabolitoGame extends React.Component {
  constructor(props) {
     super(props);
     this.state                = {interval: undefined};
     this.mainLoop             = this.mainLoop.bind(this);
     this.requestMainLoop      = this.requestMainLoop.bind(this);
     this.mouse_down           = this.mouse_down.bind(this);
     this.mouse_move           = this.mouse_move.bind(this);
     this.refresh              = this.refresh.bind(this);
     this.queryHpText          = this.queryHpText.bind(this);
     this.queryXpText          = this.queryXpText.bind(this);
     this.queryWeaponName      = this.queryWeaponName.bind(this);
     this.queryPotionSlotColor = this.queryPotionSlotColor.bind(this);
     this.queryShieldName      = this.queryShieldName.bind(this);
     this.drinkPotion          = this.drinkPotion.bind(this);
     this.sounds               = new Sounds();
     this.messenger            = new Messenger(this);
     this.gameWorld            = new GameWorld(this, this.messenger, this.sounds);
     this.drawCanvas           = new DrawCanvas(this, this.gameWorld);
     this.mouseState           = {cursorX:0,cursorY:0,clicked:0};
     this.animationInProgress  = false;
     this.fps                  = 25;
     this.ticksLow             = 0;
     this.ticksHigh            = 0;
     this.initTextarea         = false;

     // Setting global callbacks
     setInterval( this.requestMainLoop, 1000 / this.fps );
     addEventListener('resize', this.refresh, false);
  }

  refresh() {
     this.setState(this.state);
  }

  requestMainLoop() {
     if ( this.ticksHigh < 60 * 60 * 60 ) {
        ++this.ticksLow;
        if ( this.ticksLow >= this.fps ) {
           this.ticksLow = 0;
           ++this.ticksHigh;
           this.setMissionTimer(Math.floor(this.ticksHigh / 3600), Math.floor(this.ticksHigh / 60) % 60, this.ticksHigh % 60)
        }
     }
     if ( !this.initTextarea && this.textarea ) {
        this.initTextarea = true;
        this.textarea.value = "Hero enters Diabolito's dungeon.";
     }
     requestAnimationFrame(this.mainLoop);
  }

  getPairText(hp, baseHp) {
     return (hp ||0).toString()+"/"+(baseHp || 0).toString();
  }

  queryHpText() {
     return "Hp: "+this.getPairText(this.gameWorld.getCharacterUniqueAttributes(0).hp, this.gameWorld.getCharacterSharedAttributes(0).baseHp);
  }

  queryXpText() {
     return "Xp: "+this.getPairText(this.gameWorld.getCharacterUniqueAttributes(0).xp, this.gameWorld.minimalLevelXp(this.gameWorld.getCharacterSharedAttributes(0).level+1));
  }

  queryLevelText() {
     return "Player's level: "+this.gameWorld.getCharacterSharedAttributes(0).level;
  }

  queryWeaponName() {
     return "Weapon: "+this.gameWorld.getCharacterHoldedObjectAttribute(0,"weapon","name");
  }

  queryPotionSlotColor(i) {
     if ( this.gameWorld.getCharacterUniqueAttributes(0).potions && this.gameWorld.getCharacterUniqueAttributes(0).potions[i] ) {
        return {color: this.gameWorld.getCharacterUniqueAttributes(0).potions[i].color};
     }
     return {color:"#4682B4"};
  }

  refreshHpValues() {
     this.hpBar.innerText = this.queryHpText(); 
  }

  refreshXpValues() {
     this.xpBar.innerText = this.queryXpText(); 
  }

  refreshLevelValues() {
     this.levelBar.innerText = this.queryLevelText(); 
  }

  refreshWeaponName() {
     this.weaponBar.innerText = this.queryWeaponName(); 
  }

  refreshPotionBelt() {
     for (var i = 0; i < 8; ++i) {
        if ( this["potionButton"+i] ) {
           this["potionButton"+i].style = "color:"+this.queryPotionSlotColor(i).color+";";
        }
     }
  }

  queryShieldName() {
     return "Armor: "+this.gameWorld.getCharacterHoldedObjectAttribute(0,"shield","name");
  }

  refreshShieldName() {
     this.shieldBar.innerText = this.queryShieldName(); 
  }

  setMissionTimer(hh, mm, ss) {
     this.missionTimer.innerText = "Elapsed time: "+hh.toString().padStart(2,"0")+":"+mm.toString().padStart(2,"0")+":"+ss.toString().padStart(2,"0");
  }

  mainLoop() {
     if ( !this.animationInProgress ) {
        this.animationInProgress = true;
        var retobj = {};
        var currentTarget = this.drawCanvas.draw(this.mouseState, retobj);
        if ( !retobj.failed ) {
           if ( this.mouseState.clicked ) {
              this.mouseState.clicked = 0;
              this.gameWorld.setCharacterPathWithBfs(0, currentTarget);
           }
           this.gameWorld.moveCharacters();
           this.gameWorld.giveInstructionsToNPCsWithAI();
        }
        this.animationInProgress = false;
     }
  }

  mouse_down(event) {
     this.mouseState.clicked = 1; 
  }

  mouse_move(event) {
     [this.mouseState.cursorX, this.mouseState.cursorY] = [event.clientX,event.clientY];
  }

  drinkPotion(i) {
     var self = this;
     return function(){
        self.gameWorld.getCharacterUniqueAttributes(0).setUsePotion = i;
     };
  }

  render() {
    this.drawCanvas.refreshScreenConstants(true);

    return (
      <div className="diabolito-main">
         <div className="diabolito-canvas">
         <canvas ref={canvas => (this.canvas = canvas)} id="canvas" width="500" height="500" onMouseDown={this.mouse_down} onMouseMove={this.mouse_move}>
            Your browser doesn't support html5 canvas.
         </canvas>
         </div>
         <div className="diabolito-bar">
            <div className="diabolito-control-panel">
               <div className="diabolito-control-half-spacer"></div>
               <div className="diabolito-character-status">
                  <p className="diabolito-control-row">
                     <span className="diabolito-control-mini-spacer"></span>
                     <span className="diabolito-control-box" ref={span => (this.hpBar = span)}>{this.queryHpText()}</span>
                     <span className="diabolito-control-box" ref={span => (this.xpBar = span)}>{this.queryXpText()}</span>
                     <span className="diabolito-control-box" ref={span => (this.levelBar = span)}>{this.queryLevelText()}</span>
                  </p>
                  <p className="diabolito-control-row">
                     <span className="diabolito-control-mini-spacer"></span>
                     <span className="diabolito-control-box" ref={span => (this.weaponBar = span)}>{this.queryWeaponName()}</span>
                     <span className="diabolito-control-box" ref={span => (this.shieldBar = span)}>{this.queryShieldName()}</span>
                     <span className="diabolito-control-box" ref={span => (this.missionTimer = span)}>Elapsed time: --:--:--</span>
                  </p>
               </div>
               <div className="diabolito-control-half-spacer"></div>
               <div className="diabolito-character-text">
                  <div className="diabolito-character-belt">
                     <button className="diabolito-belt-button" ref={button => (this.potionButton0 = button)} style={this.queryPotionSlotColor(0)} onClick={this.drinkPotion(0)}>&#9632;</button>
                     <button className="diabolito-belt-button" ref={button => (this.potionButton1 = button)} style={this.queryPotionSlotColor(1)} onClick={this.drinkPotion(1)}>&#9632;</button>
                     <button className="diabolito-belt-button" ref={button => (this.potionButton2 = button)} style={this.queryPotionSlotColor(2)} onClick={this.drinkPotion(2)}>&#9632;</button>
                     <button className="diabolito-belt-button" ref={button => (this.potionButton3 = button)} style={this.queryPotionSlotColor(3)} onClick={this.drinkPotion(3)}>&#9632;</button>
                     <button className="diabolito-belt-button" ref={button => (this.potionButton4 = button)} style={this.queryPotionSlotColor(4)} onClick={this.drinkPotion(4)}>&#9632;</button>
                     <button className="diabolito-belt-button" ref={button => (this.potionButton5 = button)} style={this.queryPotionSlotColor(5)} onClick={this.drinkPotion(5)}>&#9632;</button>
                     <button className="diabolito-belt-button" ref={button => (this.potionButton6 = button)} style={this.queryPotionSlotColor(6)} onClick={this.drinkPotion(6)}>&#9632;</button>
                     <button className="diabolito-belt-button" ref={button => (this.potionButton7 = button)} style={this.queryPotionSlotColor(7)} onClick={this.drinkPotion(7)}>&#9632;</button>
                  </div>
               </div>
               <div className="diabolito-control-half-spacer"></div>
               <div className="diabolito-character-text">
                  <textarea readOnly unselectable="on" className="diabolito-messenger" ref={textarea => (this.textarea = textarea)} id="diabolito-messenger" rows="5" cols="80"></textarea>
               </div>
            </div>
         </div>
      </div> );
  }
}

var mountNode = document.getElementById("diabolito-widget-holder");
ReactDOM.render(<DiabolitoGame/>, mountNode);

</script>

<!-- 
  HTML  
-->
<html>
   <body>
      <div id="diabolito-widget-holder"></div>
   </body>
</html>
