<!DOCTYPE HTML>
<html>
   <head>
      <style>
         body {
            margin : 0px;
            padding: 0px;
            cursor : none;
         }
      </style>
   </head>
   <body>
   	<canvas id="canvas" width="500" height="500">
      Your browser doesn't support html5 canvas.
      </canvas>
      <script>
         var mainItem     = document.getElementById('canvas');
         var context      = mainItem.getContext('2d');

         var SPECIAL_COLORS = {WOODBROWN:"#966F33",IRON:"#434b4d",STEEL:"#4682B4",POISON:"#00FF00"};

         var screenWidth  = mainItem.width  = window.innerWidth  - 20;
         var screenHeight = mainItem.height = window.innerHeight - 20;
         var screenScale  = Math.min( screenWidth, screenHeight ) / 2;
         var tileSize = 35;
         var errorTolerance = 0.01;
         var mapRadiusX = screenWidth/2/tileSize/Math.sqrt(3);
         var mapRadiusY = screenHeight/2/tileSize;
         var mapRadius = Math.ceil(2 * Math.max(mapRadiusX,mapRadiusY));

         var fps = 25;
         var aiFrequencyDecreaseRatio = 5; // AI runs in every (1 / fps * aiFrequenceDecreasingRatio) second
         var aiCounter = 0;
         var deathSpeed = 1/25;
         var attackDeviance = 0.6;
         var ANIMATION;

         var curX = 0;
         var curY = 0;
         var currentTarget = 0;

         //================================= AVATAR ANIMATION BEGINS =================================

         function fromChar(chr,shift) {
            var retval = chr.charCodeAt(0);
            if ( chr == "{" ) return 39-shift;
            if ( chr == "}" ) return 92-shift;
            return retval -= shift;
         }

         function stringDecoder(period,shift,code) {
            var [ptr1,counter,retval,row] = [0,0,[],[]];
            while (ptr1 < code.length) {
               var tuple = [fromChar(code[ptr1],shift),fromChar(code[ptr1+1],shift),5];
               if ( code[ptr1+2] == '|' ) tuple[2] = 12;
               if ( code[ptr1+2] == '~' ) tuple[2] = 15;
               ptr1+=2+(tuple[2]!=5);
               row.push(tuple);
               ++counter;
               if ( counter == period ) {
                  retval.push(row);
                  row = [];
                  counter = 0;
               }
            }
            return retval;
         }

         // Took from http://www.rgagnon.com/jsdetails/js-0024.html.
         function beep() {
           (new
            Audio(
            "data:audio/wav;base64,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 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU="
            )).play();
         }

         var characterBodyDrawData = stringDecoder(23,30,'2;1@0F/L0R0W0}1b1h1o/*~1;|0M|9>:E:M:U8}4Z5a5i6p6v3<3B3J0Q+U1X1^.c7h?j/)~2;|1L|:>;F<M<U:}5Y5`5g6o7v6=9B:I;N:U1V-}(c+g,l/(~2;|3I|5=4D3K1R-W6V7_8g;o?v;:=A>H>N=T1W-})b%i!n/)~2;|1K|4=.Q1J3C*U7W9_<hDmKr;>=C>J@O?U1X,](b)i*o.-~2?|2L|3?3G3N/S*T7X8_9f>kEo7?:F:L:S:Z2]1X0d3j4p.*~1=|2K|6?5F3L2R-X6W3]2c9g?i2;2C2K.P+T5V7]8c:i;n/{~2;|3J|8<9D;L;T:Z4U0Z.`0f2k3<.L2G3?+Q8Y:`=eCiIl.)~1<|2L|;<=B@H@O@V3Y/a*h%p w2?1A1H.N*Q6Y6`8g>jEk/-~1>|2L|8@=C@LASAY1Y-`(h)o*u/;-A+H*O*V/U/}/c0k1r/+~1;|0I|=>>F>N>V<]7V7]8f9n;v0;/A.G-N,U1U1}0d7c=a0*~2:|1J|=:?AAI@Q>X8U8}8c:k<r291?2E1J1P:S:Y:b=h@o0(~29|3F|;<;B:I8Q5X2R.Y*`-e2j4:7?8E;H=M3T.},c)k&r0)~1:|2I|<<;C8J5Q1V9T:Y<_@dFh2=2A4E9H=K2V-})c)j(r0-~2=|2J|<?:F7M4R0W8U:}<bAeFg2;2A2F3K3P8P7W7^;a@c/*~3;|3G|<;=C=K<R;Y2Q2X2_3f7m0:/@.G,L)R2Q1V3^7c9j0{~29|2E|=:?@AFBMBS8P5V2[2c2j/;/@,F*L)R2T3Y5^:d?f0)~2;|2H|><@ACHEMFT7}4e9U1n/x/>.D+I)O{T2V1^2e8e=e/-~2=|2J|==?CBHDODV7^9V3d5u4m.=,D+K,R-X2X2_2f2n3v1+~3<|3L|?=ACBKAR@X;X;_;f:n:u.;-B-I,P-W3U2]2e5b5^1*~3:|3I|?:@A@H@P?W:U;};b:i9p/:.@.E/K1P:S:f:_;Y:l1(~39|4G|>:@@@F?N=T2Y3S0^1d3i/:/@0F1L2Q;S=U<X:}8_2)~4:|4H|?:?A?H=P8W3}3T3l3d3t/=.B/H/M0S:V;_<[:b8e1-~4=|4J|>=@D@K@S<Y2W2d3j2]3p.;-B,J-P-W3T2Z2b3i3p2+~3;|3H|?;@B@I@P?W:T9a;d;[9`>:??>D>J<O3S2_3Y3e3k1(~39|3G|/9.?-F.M0T:S<X=^<d9i=9<I>C>>=N3S1V1Y3[5^2)~39|3G|0:.@/H0O5W:S;[;c;k:t?=>C?I>O<S3W3Z2^3b4e1-~3=|3K|/=-D-L.R1X:W;];e;k:q@9B@CHDODV7U6^6f5n4v4*~6;|7I|1>0F/M1T2[?T?[?b?j=q;;;B;H<M<R<R<Y<`;g8n4*~6:|5G|2:1A0I2Q3X7R7Y6`2c,d>:?@@FBLDQ<Q=W<}7c4i4(~59|5F|2:/?.E,M+T9V7P<}=d;j?;@@BFCKFP<T;Z;a5d/g4)~5:|5I|0<.B,H*M)S5U7];i<p?x?=@CBIDNGS=W=^<e7e1f4-~5=|6L|1>.C,I*O)U5Y7^;d:m9u=<>B@H@NBT=U=}=d8d2`4*~5;|6J|2</C.J.Q/W6U6]5d4k2r;9<><C<J=Q5R4Y4a1i,p4(~49|5F|3:4A3I6Q9W=QAYE`Ae<k=9:=9C5H2M?S@ZBbEiHr5)~6;|6H|3<4B6I:O=U5Q4W4].c(i<=:A9D5H1K>SAZDaFjFq4-~6>|6K|3?5D6L:Q=U6T4Z3a.e{g9<;A=F=L<R;W;];d:i9o2*~3=|4L|2?0F0O2U3]8X8_6f5n4v4>2C0J0R1Y8W9]:c8j6p2*~2<|2K|5>6D8K:R>W5X7]:c4g-j8:8A8I<N@S7S5[3b1h/n2(~3;|3G|3<2C1K1R1Y5S:X=_<f9k8<8A8E;K?P9U2^.e)i!l3)~3;|2J|0<.A,G*O+U4W;^AfFoKw9>8C9H<NAQ:U6]5e.i&k3-~3?|3L|2@.E,K*R*Z5W<^BfBnAv8<9B8I;P?U9W;]<c4g,j2*~3=|3L|3<0D/K/S1[6X6_6g5n4v4;3A1G1O1U9T?[CaBg?l2(~2;|3I|7=7D9K;R>W5V5_3i0p,v2:.?,F-L-R;U>[AaEgJn2)~39|3I|8>8C:J<PAT5U3_.h{n s2>/B,G,M+S;W?}CaBh@o2-~2?|3L|8B9G9K;P@T5W4^1e,j%o,<+C+J,P-V2U2}1c0j/q1+~1<|2K|=>?D@M@T@}:W:]:f:n9v-;-A,G,M-T1S0Z0a/i.p1)~1;|1H|<<<C<J=Q?Y8T:[:a6g2m.9/>3E4J4N7S<Y@]=e;k1(~1:|1G|;=9D9K9R9Y1S1Z/a-i+p/:0?2D4I7L0U.],e{l"t1)~1;|0H|:>7E6L5T5[9U>}BbEgJm/<0A2D4H8M1W0^.f)k$p2-~1=|1K|:A7H5N4V4]9X<]AaBiCp-:,@-E-K/R6S8]7e7m6u1*~1;|/H|:?9F8M7U6}/S1[3b.f)h/:-@,F,M,S0T4X9}:a;e1(~2:|1H|<<=B=I>P?V7U7_6g4o3v/;,A*G*N*U0R4W8}<a@e1(~1;|1H|<==C>H@OAT8T4`3j/p+x/>,C*H)O(U1S3Z6a6g6l1-~2>|1K|:@<D>I?NBR7T8[9b5g0m.=-D+K,R,Y2W2_2g2n3u1+~3;|3L|?<ACAKARAY;W;_;g;n:u.:-A-I-P-W3U2}1d3l2t1)~39|3H|?;@A@I@W@P:U;}<c:f8j.9.>/E0K2Q:S;W;};_;c2(~39|3G|>9??@G?N?U3S2}1e2m2u0:0@0E2J3O9R:U:X:};^2)~39|3G|=:>A>H>N=T1x3R2[2e2n/>/C.H0M1R:U;Y;];a;d2-~4=|3J|>>@D?K?R>Y3U2[1a3g4m.;-B,J-Q-W2V2^1e3h4j2)~3:|3K|>;?B@I@P@V;V;];c:k:t?:???D>J<O2R3V2Z2_2b1(~39|3G|0:.A-H.O/V:R;Z;c;m<u=;=?<D<G;L4S3V3Y2]2_2)~3H|3:|/;/B/H0N0T:T;};e<o<x>=?D?J>O<T3U2Y2]2a1e2-~3>|4K|0=.D.K.S/Y:V<[=a;g:m>;?B@I@N?U:U:[;b<i=p1)~4<|3J|0=-D,L,S,[2W2^2f3m4u?9@?@G?M=R=U:]:b>fCi1*~6:|6I|2?3E4M5T5[7U5]5e6m6u>;@AAH@N@T;T7Y5}2_2e1(~5:|5G|0</B/H/O-U5T5}6f8n:v><@ABHCOAU:S6Y3]/a+e1)~4;|4H|0=/B.I-O*T5S7]9g=p@x2@0D/I-M*R;V9Z6`6g6m1,~5>|4J|>>ACBICODV5U4[4b8g=m?;?@@G@M@S;V;}<b=i>p1)~5<|5J|1=0C0I/P.W4V2}3b7g:m>9>><D;J:M6T0Y,^.d1j1{~59|5G|1=3C3J4Q4X<T<Z<`?hAp>9>?=E=J<N3T0Z,a{g"m1)~5;|5I|1>4D5L7T8[<T>]@eDmIs=;>B=J;O<R;X=^?dDjHo1-~5?|5N|2A5G6M8U8}4X0^,b*i)p' );

         var weaponDrawData = stringDecoder(6,35,'4W$R7#A#K#>a$#-#7#0Z#Q@`?Z-V7#A#K#1}BY2T6#A#K#/[EY5W7#A#K#0Y?_0Z7#@#J#2]0Z$S7#A#K#>_0U$J7#A#K#E[/V#J7#A#K#E^##-#7#/}#YAb##-#7#0Z{MC}5U{Q7#A#K#:]BR0T7#A#K#7[BQ3T7#A#K#5]7V(T7#A#K#@^&#-#7#/W#OFW$#+#7#-W$JLY$#,#7#,Y%KJ[##-#7#2^-WU###-#6#2}2PF[6V.Y7#A#K#BW5W-X7#A#K#=}##-#7#5Y-]A^%#-#7#3[*VD}##-#BV5Y6RU###-#AU:}=RU###-#AY5^9SU###-#J[7_HXU###-#BU8]GUU###-#IV0YBZU###-#KV.Y=ZU###-#KW.[<ZU###-#GZ4}BZU###-#AV=}JSU###-#6RBZLQU###-#6QCZNOU###-#AX7aH[U###-#7]C}MTU###-#EW6^HZU###-#ET/ZA[U###-#FW/_@]U###-#DZ6`F}U###-#5ZC}PRU###-#2WFYMNU###-#0XEYNPU###-#2[E`PVU###-#1XE]JOU###-#;P?^JYU###-#=U:`H[U###-#=V9bF_U###-#3Y;`EYU###-#0XD[KQU###-#/YGYNMU###-#,ZGWNJU#F^FQ0^A#K#U#E[EU1}A#K#U#DZBN5VA#K#U#AYCN9YA#K#U#C^ET6YA#K#U#E[FQ2}A#K#U#BS:L3[A#K#V#?T;N4YA#K#U#AX=R3_A#K#U#DZ4P7#A#K#1_?Z0Q7#A#K#9`DX6Q7#A#K#2ZFZ6T7#A#K#/YH[8V7#A#K#.VEW5P7#A#K#2}=V0L7#A#K#8^>V.L6#A#K#<_=W/N7#A#K#<a##-#7#A#K#U###-#7#A#K#U#');

         var drawDescriptorForWarrior = [[0],[0,1],[1],[1,2],[2],[2,3],[3],[3,4],[4],
                                         [5],[5,6],[6],[6,7],[7],[7,8],[8],[8,9],[9],
                                         [10],[11],[11,12],[12],
                                         [13],[13,14],[14],[14,15],[15],[15,16],[16],[16,17],[17],
                                         [18],[18,19],[19],[19,20],[20],[20,21],[21],[21,22],[22]];

         var drawDescriptorForWarriorWithWeapon = [[23],[23,24,0.75,0.25],[23,24],[23,24,0.25,0.75],[24],[23,24,-0.25,1.25],[23,24,-0.5,1.5],[23,24,-0.75,1.75],[23,24,-1,2],
                                                   [0],[0,1],[1],[1,2],[2],[2,3],[3],[3,4],[4],
                                                   [5],[5,6],[6],[6,7],[7],[7,8],[8],[8,9],[9],
                                                   [10],[11],[11,12],[12],
                                                   [13],[13,14],[14],[14,15],[15],[15,16],[16],[16,17],[17],
                                                   [18],[18,19],[19],[19,20],[20],[20,21],[21],[21,22],[22],
                                                   [26],[26,27,0.75,0.25],[26,27],[26,27,0.25,0.75],[27],[26,27,-0.75,1.75],[26,27,-0.5,1.5],[26,27,-0.25,1.25],[26,27,-1,2]];

         var drawDescriptorForWarriorWithShield =
            [[25,25,0.5,0.5,10],
             [0],[0,1],[1],[1,2],[2],[2,3],[3],[3,4],[4],
             [5],[5,6],[6],[6,7],[7],[7,8],[8],[8,9],[9],
             [10],[11],[11,12],[12],
             [13],[13,14],[14],[14,15],[15],[15,16],[16],[16,17],[17],
             [18],[18,19],[19],[19,20],[20],[20,21],[21],[21,22],[22],
             [28,28,0.5,0.5,10]];

         var drawDescriptorForWarriorWithWeaponAndShield =
            [[23],[23,24,0.75,0.25],[23,24],[23,24,0.25,0.75],[24],[23,24,-0.25,1.25],[23,24,-0.5,1.5],[23,24,-0.75,1.75],[23,24,-1,2],[25,25,0.5,0.5,10],
             [0],[0,1],[1],[1,2],[2],[2,3],[3],[3,4],[4],
             [5],[5,6],[6],[6,7],[7],[7,8],[8],[8,9],[9],
             [10],[11],[11,12],[12],
             [13],[13,14],[14],[14,15],[15],[15,16],[16],[16,17],[17],
             [18],[18,19],[19],[19,20],[20],[20,21],[21],[21,22],[22],
             [26],[26,27,0.75,0.25],[26,27],[26,27,0.25,0.75],[27],[26,27,-0.75,1.75],[26,27,-0.5,1.5],[26,27,-0.25,1.25],[26,27,-1,2],[28,28,0.5,0.5,10]];

         var drawDescriptors = [drawDescriptorForWarrior,drawDescriptorForWarriorWithWeapon,drawDescriptorForWarriorWithShield, drawDescriptorForWarriorWithWeaponAndShield];

         var descriptorValueToColor=[2,2,2,2,2,
                                     3,3,3,3,3,
                                     0,1,1,
                                     4,4,4,4,4,
                                     5,5,5,5,5,
                                     6,6,7,6,6,7];

         var heroColoring =['orange','lightgreen','orange','green','orange','green'];
         var devilColoring =['crimson','tomato','crimson','tomato','crimson','tomato'];
         var attackColoring =['red','red','red','red','red','red'];

         //================================== AVATAR ANIMATION ENDS =================================

         var levelMap= [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0],
                        [0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0],
                        [0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0],
                        [0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,0,2,2,2,2,0,3,3,3,3,3,3,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,0,2,2,2,2,0,1,0,0,0,0,0,0,0],
                        [0,0,6,1,13,1,7,1,1,1,1,1,1,0,2,2,2,2,2,1,0,1,1,1,1,1,0],
                        [0,0,1,1,13,1,7,1,1,1,1,1,1,0,0,0,0,0,0,1,0,1,17,5,5,5,0],
                        [0,0,1,1,13,1,7,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,0],
                        [0,0,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,0],
                        [0,0,4,4,4,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,0,0],
                        [0,0,1,1,4,1,1,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,1,0,0],
                        [0,0,1,1,4,4,4,1,0,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,1,1,1,1,4,4,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,0,0],
                        [0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,0,0],
                        [0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                        [0,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0],
                        [0,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];

         var colorDescription = ["STONEWORLD","SNOWWORLD","FIREWORLD","WATER","CARPET","FAKEDOOR"];
         var floorColors = ["#AAAAAA","white","firebrick","blue","magenta","#AAAAAA"];
         var wallColors = ["gray","#CDCDCD","darkred","blue","magenta","#835C3B"];


         var ATTRIBUTES_BAREFIST       = {name:"none", value: 0, size:0};
         var ATTRIBUTES_WOODEN_STICK   = {name:"wooden stick"  ,color:SPECIAL_COLORS["WOODBROWN"],width:30,height:4,value:1,holder:"weapon"};
         var ATTRIBUTES_IRON_BAR       = {name:"iron bar"      ,color:SPECIAL_COLORS["IRON"]     ,width:30,height:4,value:2,holder:"weapon"};
         var ATTRIBUTES_STEEL_SWORD    = {name:"steel sword"   ,color:SPECIAL_COLORS["STEEL"]    ,width:30,height:4,value:3,holder:"weapon"};
         var ATTRIBUTES_SILVER_SWORD   = {name:"silver sword"  ,color:'silver'                   ,width:30,height:4,value:4,holder:"weapon"};
         var ATTRIBUTES_GOLD_SWORD     = {name:"gold sword"    ,color:'gold'                     ,width:30,height:4,value:5,holder:"weapon"};
         var ATTRIBUTES_CRISTAL_SWORD  = {name:"cristal sword" ,color:'cyan'                     ,width:30,height:4,value:6,holder:"weapon"};

         var ATTRIBUTES_MINISHIELD     = {name:"minishield"    ,color:"black",width:11,height:12,value:1,size:0.75,holder:"shield"}
         var ATTRIBUTES_BUCKLER_SHIELD = {name:"buckler"       ,color:"black",width:15,height:12,value:2,size:1.00,holder:"shield"}
         var ATTRIBUTES_BATTLESHIELD   = {name:"battleshield"  ,color:"black",width:19,height:12,value:3,size:1.25,holder:"shield"}
         var ATTRIBUTES_KITE_SHIELD    = {name:"kite shield"   ,color:"black",width:24,height:12,value:4,size:1.50,holder:"shield"}
         var ATTRIBUTES_TOWER_SHIELD   = {name:"tower shield"  ,color:"black",width:30,height:12,value:5,size:2.00,holder:"shield"}

         function heroHpIncreaser(value) {
            return ()=>{ isCharacterAlive(0) && (characters[0][6].hp=Math.min(characters[0][4].baseHp,characters[0][6].hp+value));};
         }

         function damageInRadius(radius, value) {
            return ()=>{
               var characterIndex = createCharacterIndex();
               iterateOverBucketItemsAroundPos(characters[0][0],
                                               characterBuckets,
                                               (i)=>{
                                                   if ( manhattan(characters[0][0], characters[i][0]) < radius ) {
                                                      damage(i,value);
                                                   }
                                                });
            };
         }

         var ATTRIBUTES_MINOR_HEALTH_POTION = {name:"minor health potion",color:"red"                   ,width:5,height:5,value:-1,holder:"potions",effect:heroHpIncreaser(30),effectText:"hero heals"};
         var ATTRIBUTES_HEALTH_POTION       = {name:"health potion",      color:"red"                   ,width:7,height:7,value:-1,holder:"potions",effect:heroHpIncreaser(60),effectText:"hero heals"};
         var ATTRIBUTES_MAJOR_HEALTH_POTION = {name:"major health potion",color:"red"                   ,width:9,height:9,value:-1,holder:"potions",effect:heroHpIncreaser(90),effectText:"hero heals"};
         var ATTRIBUTES_MINOR_POISON_GAS    = {name:"minor poison gas"   ,color:SPECIAL_COLORS["POISON"],width:5,height:5,value:-1,holder:"potions",effect:damageInRadius(10,10),effectText:"releases deadly poison gas"};
         var ATTRIBUTES_POISON_GAS          = {name:"poison gas"         ,color:SPECIAL_COLORS["POISON"],width:7,height:7,value:-1,holder:"potions",effect:damageInRadius(10,30),effectText:"releases deadly poison gas"}
         var ATTRIBUTES_MAJOR_POISON_GAS    = {name:"major poison gas"   ,color:SPECIAL_COLORS["POISON"],width:0,height:9,value:-1,holder:"potions",effect:damageInRadius(10,30),effectText:"releases deadly poison gas"}

         var ATTRIBUTES_DEVILGUY       = {name:"devilguy",scale:0.75,coloring:devilColoring,slowness:10,range:4,baseAttack:1,baseDefense:0,baseHp:5};
        
         // all characters on the map - 0th is the player, [[y,x], faceDir (0=S, 1=E, 2=N, 3=W), phase, path, shared_attributes_in_class, attackbit, non_shared_attributes]
         var characters = [[[15.5,15.5],0,0,[],{name:"hero",scale:1.00,coloring:heroColoring,slowness:5,range:50,baseAttack:1,baseDefense:0,baseHp:20},0,{hp:20,exists:1,weapon:undefined,shield:undefined,potions:[undefined,undefined,undefined,undefined,undefined]}],
                           [[10.5,10.5],0,0,[],ATTRIBUTES_DEVILGUY,0,{hp: 5,exists:1}],
                           [[6.5,10.5] ,0,0,[],ATTRIBUTES_DEVILGUY,0,{hp: 5,exists:1}],
                           [[7.5,11.5] ,0,0,[],ATTRIBUTES_DEVILGUY,0,{hp: 5,exists:1}],
                           [[7.5,12.5] ,0,0,[],ATTRIBUTES_DEVILGUY,0,{hp: 5,exists:1}],
                           [[4.5,20.5] ,0,0,[],ATTRIBUTES_DEVILGUY,0,{hp: 5,exists:1}],
                           [[22.5,4.5] ,0,0,[],ATTRIBUTES_DEVILGUY,0,{hp: 5,exists:1}],
                          ];

         stuffs = [
                  [[11.5,15.5],ATTRIBUTES_IRON_BAR     ,{exists:1}],
                  [[11.5,16.5],ATTRIBUTES_STEEL_SWORD  ,{exists:1}],
                  [[10.5,16.5],ATTRIBUTES_GOLD_SWORD   ,{exists:1}],
                  [[10.5,17.5],ATTRIBUTES_CRISTAL_SWORD,{exists:1}],
                  [[11.5,17.5],ATTRIBUTES_MINISHIELD   ,{exists:1}],
                  [[11.5,18.5],ATTRIBUTES_SILVER_SWORD ,{exists:1}],
                  [[22.5,13.5],ATTRIBUTES_MAJOR_HEALTH_POTION,{exists:1}],
                  [[22.5,14.5],ATTRIBUTES_MAJOR_HEALTH_POTION,{exists:1}],
                  [[22.5,15.5],ATTRIBUTES_HEALTH_POTION,{exists:1}],
                  [[22.5,16.5],ATTRIBUTES_MINOR_HEALTH_POTION,{exists:1}],
                  [[22.5,17.5],ATTRIBUTES_MINOR_POISON_GAS,{exists:1}],
                  [[22.5,18.5],ATTRIBUTES_MAJOR_HEALTH_POTION,{exists:1}],
                  ];

         var characterBuckets;
         var stuffBuckets;
         var bucketGridSize = 15;
         var keyMaxRowSize = 10000;
         var bucketMaxRowSize = 10000;
         var multipleObjectCapacity = 5;

         function manhattan(p1,p2) {
            return Math.abs(p1[0]-p2[0]) + Math.abs(p1[1]-p2[1]);
         }

         function drawBox(boxX,boxY,boxSize,boxSize2,boxColor, exists) {
            context.beginPath();
            context.rect(boxX, boxY, Math.round(boxSize*exists), Math.round(boxSize2*exists));
            context.fillStyle = boxColor;
            context.fill();
         }

         function drawRectangle(boxX,boxY,boxSize1,boxSize2,boxColor) {
            context.beginPath();
            context.rect(boxX, boxY, boxSize1, boxSize2);
            context.fillStyle = boxColor;
            context.fill();
         }

         function drawBoxExtended(ux,uy,i,ind1,ind2,w1,w2,rad) {
            var phaseKey = getKey(characters[i][1], characters[i][2]);
            var rimage = characterBodyDrawData[phaseKey];
            var wimage = weaponDrawData[phaseKey];
            var scale = characters[i][4].scale;
            var characterColors = characters[i][4].coloring;
            if ( characters[i][5] ) {
               characterColors = attackColoring;
            }
            var exists = characters[i][6].exists;
            var shieldrad   = getCharacterHoldedObjectAttribute(i,"shield","size");
            var weaponcolor = getCharacterHoldedObjectAttribute(i,"weapon","color");

            var simage = rimage;
            var cind = ind1;
            if ( w1 === undefined ) {
               w1 = 0.5;
            }
            if ( w2 === undefined ) {
               w2 = 0.5;
            }
            var isShield = ((ind1 == 25) || (ind1 == 28))&&(shieldrad > errorTolerance);
            if ( ind1 > 22 ) {
               simage = wimage;
               ind1 -= 23;
               if ( ind2 !== undefined ) {
                  ind2 -= 23;
               }
               if ( simage[ind1][1] < 3 ) {
                  return;
               }
            }
            var colorIndex = descriptorValueToColor[cind];
            var color = characterColors[colorIndex];
            if ( colorIndex > 5 ) {
               if ( colorIndex === 6 ) {
                  color = weaponcolor;
               }
               if ( colorIndex === 7 ) {
                  color = "black";
               }
            }

            var percentage = tileSize / 50;
            if ( ind2 === undefined ) {
               drawBox(ux+simage[ind1][0]*percentage,
                       uy+simage[ind1][1]*percentage*scale,
                       simage[ind1][2]*percentage,
                       simage[ind1][2]*percentage,
                       color,
                       exists);
            } else {
               var orad = (rad===undefined?simage[ind1][2]:rad*2)*percentage;
               drawBox(ux+(Math.floor(simage[ind1][0]*w1+simage[ind2][0]*w2)-(rad===undefined?0:rad))*percentage,
                       uy+(Math.floor(simage[ind1][1]*w1+simage[ind2][1]*w2)-(rad===undefined?0:rad))*percentage*scale-orad*(isShield?shieldrad/2-0.5:0),
                       orad,
                       orad*(isShield?shieldrad:1),
                       color,
                       exists);
            }
         }

         function drawCharacter(y,x,i) {
            var drawDescriptor = drawDescriptors[(getCharacterHoldedObjectAttribute(i,"weapon","value") != 0)
                                               + (getCharacterHoldedObjectAttribute(i,"shield","value") != 0)*2];
            var scale = characters[i][4].scale;
            var cx = (x + y) * Math.sqrt(3) * tileSize + screenWidth / 2;
            var cy = (x - y) * tileSize + screenHeight / 2;
            var percentage = tileSize / 50;
            var ymax = 100 * percentage * scale;
            var xmax = 54  * percentage;
            var ux = Math.floor(cx - xmax/2);
            var uy = Math.floor(cy - ymax + ymax * percentage * 0.1);
            drawDescriptor.map(box=>drawBoxExtended(ux,uy,i,...box));
            characters[i][5] = 0;
         }

         function drawBackground() {
            context.fillStyle = "black";
            context.fillRect(0,0,screenWidth,screenHeight);
         }

         function contextPathForObjectDraw(obj) {
            context.beginPath();
            for ( var i = 0; i < obj.ps.length; ++i ) {
               ( i == 0 ? context.moveTo( Math.floor(obj.ps[i].x), Math.floor(obj.ps[i].y) ) : context.lineTo( Math.floor(obj.ps[i].x), Math.floor(obj.ps[i].y) ) );
            }
            context.closePath();
         }

         function drawFloor(tile, color) {
            context.fillStyle = color;
            context.strokeStyle = color;
            contextPathForObjectDraw(tile);
            context.fill();
            context.stroke();
         }

         function drawTile(tile,color) {
            context.strokeStyle = color;
            contextPathForObjectDraw(tile);
            context.stroke();
         }

         function getFloorTile(y,x,obi) {
            var px = (x + y) * Math.sqrt(3) * tileSize + screenWidth / 2;
            var py = (x - y) * tileSize + screenHeight / 2;
            obi.ps = [{x:px,y:py-tileSize},{x:px + Math.sqrt(3) * tileSize,y:py},{x:px,y:py+tileSize},{x:px - Math.sqrt(3) * tileSize,y:py}];
            return obi;
         }

         function getFloorTileScale(y,x,obi,scale) {
            var px = (x + y) * Math.sqrt(3) * tileSize + screenWidth / 2;
            var py = (x - y) * tileSize + screenHeight / 2;
            obi.ps = [{x:px,y:py-tileSize*scale},{x:px + Math.sqrt(3) * tileSize*scale,y:py},{x:px,y:py+tileSize*scale},{x:px - Math.sqrt(3) * tileSize*scale,y:py}];
            return obi;
         }

         function getKey(diri,phi) {
            return (1+diri*2)*9 + phi;
         }

         function drawCursor(x,y) {
            context.fillStyle = "red";
            contextPathForObjectDraw({ps:[{x:x,y:y},{x:x+15,y:y+20},{x:x,y:y+25}]});
            context.fill();
         }

         function drawWall(y,x,num, color) {
            var px = (x + y) * Math.sqrt(3) * tileSize + screenWidth / 2;
            var py = (x - y) * tileSize + screenHeight / 2;

            var bit1 = (num % 2) * 2 - 1;
            var bit2 = (num >= 2) * 2 - 1;

            if ( num < 2 ) {
               context.globalAlpha = 1.0;
               context.fillStyle   = color;
            } else {
               context.globalAlpha = 0.75;
               context.fillStyle   = "#000000";
            }
            var sy = 1;
            contextPathForObjectDraw( {ps:[{x:px,y:py + bit2 * tileSize+sy},{x:px + bit1 * Math.sqrt(3) * tileSize, y:py+sy},{x:px + bit1 * Math.sqrt(3) * tileSize, y:py - 2 * tileSize+sy},{x:px, y:py + bit2 * tileSize - 2 * tileSize+sy}]} );
            context.fill();
            context.globalAlpha = 1.0;
         }

         function getMapCell(y,x) {
            return ( y < levelMap.length && y >= 0 && x < levelMap[y].length && x >= 0 ? levelMap[y][x] : 0 );
         }

         function isMapCellVisible(y,x,cy,cx,oy,ox,sx=0.5+ox,sy=0.5+oy) {
            var dirY  = y - oy;
            var dirX  = x - ox;
            var dirL  = Math.hypot(dirX,dirY);
            dirY /= dirL;
            dirX /= dirL;

            var celly   = cy;
            var cellx   = cx;

            var dist    = 0;
            var arrived = 0;
            var limit   = 50;
            var err     = 1e-6;

            while ( limit && getMapCell( celly, cellx ) && !( celly == cy + y && cellx == cx + x ) ) {
               --limit;
               var jump  = Math.min( Math.max( ( 1 - sx ) / dirX, -sx / dirX ),
                                     Math.max( ( 1 - sy ) / dirY, -sy / dirY ) );
               dist += jump;
               sx = sx + dirX * jump;
               sy = sy + dirY * jump;
               if ( Math.abs(sx) < err && dirX < 0) {
                  sx = 1;
                  cellx -= 1;
                  arrived = 1;
               } else if ( Math.abs(1-sx) < err && dirX > 0 ) {
                  sx = 0;
                  cellx += 1;
                  arrived = 2;
               }
               if ( Math.abs(sy) < err && dirY < 0 ) {
                  sy = 1;
                  celly -= 1;
                  arrived = 3;
               } else if ( Math.abs(1-sy) < err && dirY > 0 ) {
                  sy = 0;
                  celly += 1;
                  arrived = 4;
               }
            }

            return ( celly == cy + y && cellx == cx + x );
         }

         function drawCellFloor(y,x,cy,cx,oy,ox,tiles) {
            var color = floorColors[ (getMapCell(cy+y,cx+x) - 1) % floorColors.length ];
            var tile = getFloorTile(-y+oy,x-ox,{x:x+cx,y:y+cy});
            drawFloor(tile, color);

            tiles.push(tile);
         }

         function drawCell(y,x,cy,cx,oy,ox,characterIndexer,stuffIndexer) {
            var color = wallColors[ (getMapCell(cy+y,cx+x) - 1) % wallColors.length ];
            if ( !getMapCell(cy+y,cx+x-1) ) {
               drawWall(-y+oy,x-ox,0,color);
            }
            if ( !getMapCell(cy+y-1,cx+x) ) {
               drawWall(-y+oy,x-ox,1,color);
            }

            var mapval = getMapCell(cy+y,cx+x);
            var speciality = Math.floor((mapval-1) / wallColors.length);

            {
               var i = stuffIndexer[getIndexKey([cy+y,cx+x])];
               if ( i !== undefined ) {
                  var attribs = stuffs[i][1];
                  if ( stuffs[i][2].exists ) {
                     var tile = getFloorTile(-y+oy,x-ox,{x:x+cx,y:y+cy});
                     drawRectangle(Math.round(0.5*tile.ps[1].x+0.5*tile.ps[3].x-attribs.width/2),
                                   Math.round(tile.ps[1].y-attribs.height/2),
                                   attribs.width,
                                   attribs.height,
                                   attribs.color);
                  }
               }
            }

            // table
            if ( speciality == 1 ) {
               var tile = getFloorTile(-y+oy+0.5,x-ox-0.5,{x:x+cx,y:y+cy});
               var tableColor = "#835C3B";
               drawRectangle(tile.ps[1].x-5,tile.ps[1].y,Math.floor(tileSize/7),tileSize,tableColor);
               drawRectangle(tile.ps[2].x-2,tile.ps[2].y-2,Math.floor(tileSize/7),tileSize,tableColor);
               drawRectangle(tile.ps[3].x,  tile.ps[3].y,Math.floor(tileSize/7),tileSize,tableColor);
               drawFloor(tile,tableColor);
            }

            // chair
            if ( speciality == 2 ) {
               var tile = getFloorTileScale(-y+oy+0.20,x-ox-0.20,{x:x+cx,y:y+cy},0.5);
               var tableColor = "#835C3B";
               drawRectangle(tile.ps[1].x-5,tile.ps[1].y,Math.floor(tileSize/7),tileSize/2,tableColor);
               drawRectangle(tile.ps[2].x-2,tile.ps[2].y-2,Math.floor(tileSize/7),tileSize/2,tableColor);
               drawRectangle(tile.ps[3].x,  tile.ps[3].y,Math.floor(tileSize/7),tileSize/2,tableColor);
               drawFloor(tile,tableColor);
               
               drawFloor({ps:[tile.ps[0],tile.ps[3],{x:tile.ps[3].x,y:tile.ps[3].y-tileSize},{x:tile.ps[0].x,y:tile.ps[0].y-tileSize}]}, tableColor)
            }

            var i = characterIndexer[getIndexKey([cy+y,cx+x])];
            if ( i !== undefined ) {
               drawCharacter((oy+cy+0.5)-(characters[i][0][0]),-(ox+cx+0.5)+(characters[i][0][1]),i);
            }

            if ( !getMapCell(cy+y+1,cx+x) ) {
               drawWall(-y+oy,x-ox,2,color);
            }
            if ( !getMapCell(cy+y,cx+x+1) ) {
               drawWall(-y+oy,x-ox,3,color);
            }
         }

         function getIndexKey(ps) {
            return Math.floor(ps[0])*keyMaxRowSize+Math.floor(ps[1]);
         }

         function getBucketIndex(pos) {
            return "x" + (Math.floor(pos[0] / bucketGridSize)*bucketMaxRowSize+Math.floor(pos[1] / bucketGridSize)).toString();
         }

         function iterateOverBucketItemsAroundPos(pos, buckets, func1, func2) {
            var distr = {};
            for ( var y = -1; y <= 1; ++y ) {
               for ( var x = -1; x <= 1; ++x ) {
                  var psel = getBucketIndex([(bucketGridSize-1)*y+pos[0],(bucketGridSize-1)*x+pos[1]]);
                  if ( !(psel in distr) && (psel in buckets) ) {
                     distr[psel] = 1;
                     var bucket = buckets[psel];
                     if ( func1 ) {
                        for ( var j = 0; j < bucket.length; ++j ) {
                           func1(bucket[j]);
                        }
                     }
                     if ( func2 ) {
                        func2(buckets, psel);
                        delete buckets[psel];
                     }
                  }
               }
            }
         }

         function generateBuckets(buckets,objs) {
            for ( var i = 0; i < objs.length; ++i ) {
               var psel = getBucketIndex(objs[i][0]);
               if ( !(psel in buckets) ) {
                  buckets[psel] = [];
               }
               buckets[psel].push(i);
            }
         }

         function partiallyRegenerateBuckets(pos,buckets,objs) {
            var affectedBuckets = {};
            iterateOverBucketItemsAroundPos(pos,
                                            buckets,
                                            undefined,
                                            (buckets,psel)=>{affectedBuckets[psel]=buckets[psel];});

            iterateOverBucketItemsAroundPos(pos,
                                            affectedBuckets,
                                            (i)=>{ var psel = getBucketIndex(objs[i][0]);
                                                   (buckets[psel] = buckets[psel] || []).push(i); });
         }

         function createIndexFromBuckets(buckets,objs,cleaner,condition,pos) {
            if ( buckets == undefined ) {
               buckets = cleaner();
               generateBuckets(buckets,objs);
            } else {
               partiallyRegenerateBuckets(pos,buckets,objs);
            }

            var index = {};
            iterateOverBucketItemsAroundPos(pos,
                                            buckets,
                                            (i)=>{ condition(i) && ( index[ getIndexKey(objs[i][0]) ] = i ) });

            return index;
         }
         
         function createCharacterIndex() {
            return createIndexFromBuckets(characterBuckets, characters, ()=>{ return (characterBuckets = {}); }, (i)=>{return !isCharacterFullyDead(i)}, characters[0][0]);
         }

         function createStuffIndex() {
            return createIndexFromBuckets(stuffBuckets, stuffs, ()=>{ return (stuffBuckets = {}); }, (i)=>{return 1;}, characters[0][0]);
         }

         function drawForeground( camCenter, characterIndex, visibleTiles ) {
            var cy = Math.floor(camCenter[0]);
            var cx = Math.floor(camCenter[1]);
            var oy = camCenter[0] - cy - 0.5;
            var ox = camCenter[1] - cx - 0.5;

            var cellsy = [];
            var cellsx = [];

            for ( var y = -mapRadius; y < mapRadius; ++y ) {
               for ( var x = -mapRadius; x < mapRadius; ++x ) {
                  if ( isMapCellVisible(y,x,cy,cx,oy,ox) 
                       || isMapCellVisible(y,x,cy,cx,oy,ox,0,0) 
                       || isMapCellVisible(y,x,cy,cx,oy,ox,0,1) 
                       || isMapCellVisible(y,x,cy,cx,oy,ox,1,0) 
                       || isMapCellVisible(y,x,cy,cx,oy,ox,1,1) )
                  {
                     if ( getMapCell(cy+y,cx+x) ) {
                        cellsy.push(y);
                        cellsx.push(x);
                     }
                  }
               }
            }

            var stuffIndexer = createStuffIndex();

            for ( var i = 0; i < cellsx.length; ++i ) {
               drawCellFloor(cellsy[i],cellsx[i],cy,cx,oy,ox,visibleTiles);
            }

            for ( var i = 0; i < cellsx.length; ++i ) {
               drawCell(cellsy[i],cellsx[i],cy,cx,oy,ox,characterIndex,stuffIndexer);
            }
         }

         function getPointSide(p1,p2,p3) {
            return Math.sign( (p1.y-p2.y) * (p3.x-p1.x) + (p2.x-p1.x) * (p3.y-p1.y) );
         }

         function isPointInTriangle(p1,p2,p3,pt) {
            var retval = ( getPointSide(p1,p2,p3) * getPointSide(p1,p2,pt) >= 0 )
                      && ( getPointSide(p2,p3,p1) * getPointSide(p2,p3,pt) >= 0 )
                      && ( getPointSide(p3,p1,p2) * getPointSide(p3,p1,pt) >= 0 );
            return retval;
         }

         function bfs(source,target,characterIndex) {
            if ( !getMapCell(source.y,source.x) ) {
               return [];
            }
            var hops = {};
            var findings = [[source.y,source.x]];
            hops[findings[0]]=false;
            var level = 0;
            var dirs = [[0,1],[-1,0],[0,-1],[1,0]];
            while ( level < 10 && findings.length > 0 ) {
               ++level;
               var nfindings = [];
               for ( var i = 0; i < findings.length; ++i ) {
                  for ( var j = 0; j < dirs.length; ++j ) {
                     var nextp = [(findings[i][0]+dirs[j][1]),(findings[i][1]+dirs[j][0])];
                     if ( getMapCell(nextp[0],nextp[1]) && getMapCell(nextp[0],nextp[1]) < wallColors.length
                       && hops[nextp] === undefined
                       && (nextp[0] === target.y && nextp[1] === target.x || characterIndex[getIndexKey([nextp[0],nextp[1]])] === undefined ) ) { // enemies shadowing the areas behind of them, but not themselves
                        nfindings.push(nextp);
                        hops[nextp] = findings[i];
                     }
                  }
               }
               findings = nfindings;
            }
            var tara = [target.y,target.x];
            var way = [];
            if ( hops[tara] !== undefined ) {
               way.push(tara);
               var maxi = 100;
               while(hops[tara] && maxi-- ) {
                  way.push(hops[tara]);
                  tara = hops[tara];
               }
            }
            way.reverse();
            return way;
         }

         function getCursorsTile(tiles, cx, cy) {
            for ( var i = 0; i < tiles.length; ++i ) {
               if ( isPointInTriangle( tiles[i].ps[0], tiles[i].ps[1], tiles[i].ps[3], {x:cx,y:cy} )
                 || isPointInTriangle( tiles[i].ps[1], tiles[i].ps[2], tiles[i].ps[3], {x:cx,y:cy} ) ) {
                  return tiles[i];
               }
            }
         }

         function destroying(index) {
            characters[index][6].exists -= deathSpeed;
         }

         function kill(index) {
            sendMessage(characters[index][4].name+" dies");
            destroying(index);
         }

         function capitalize(text) {
            return text[0].toUpperCase() + text.substring(1);
         }

         function sendMessage(text) {
            console.log(capitalize(text)+".");
         }

         function getCharacterHoldedObjectAttribute(i,holder,attribute) {
            return (characters[i][6][holder]||ATTRIBUTES_BAREFIST)[attribute];
         }

         function damage(attacked, value) {
            if ( value <= 0 ) {
               return;
            }
            beep();
            characters[attacked][6].hp -= value;
            if ( characters[attacked][6].hp < 0 ) {
               characters[attacked][6].hp = 0;
               kill(attacked);
               return;
            }
            characters[attacked][5] = 1;
         }

         function usePotion(number) {
            if ( characters[0][6].potions === undefined
              || number >= characters[0][6].potions.length
              || characters[0][6].potions[number] === undefined ) {
               return;
            }
            var exec = characters[0][6].potions[number];
            characters[0][6].potions[number] = undefined;
            sendMessage('Hero uses '+exec.name+', '+exec.effectText);
            exec.effect();
         }

         function attack(attacker, attacked) {
            var attackValue  = Math.round( (characters[attacker][4].baseAttack  + getCharacterHoldedObjectAttribute(attacker,"weapon","value"))*(1.0 - attackDeviance*Math.random()) );
            var defenseValue = Math.round( (characters[attacked][4].baseDefense + getCharacterHoldedObjectAttribute(attacker,"shield","value"))*(1.0 - attackDeviance*Math.random()) );
            var damageValue = Math.max(attackValue - defenseValue,0);
            sendMessage(characters[attacker][4].name + " attacks " + characters[attacked][4].name + " and " + (damageValue <= 0 ? "misses" : "damages " + damageValue + " (+"+attackValue+"-"+defenseValue+") points"));
            damage(attacked,damageValue);
         }

         function pickup(index,stuff) {
            var holder = stuffs[stuff][1].holder;
            var current = getCharacterHoldedObjectAttribute(index,holder,"value")
            var whatif  = stuffs[stuff][1].value;
            if (whatif >= 0 ) {
               // hero hold can only once from it at a time, value decides
               if ( whatif > current ) {
                  if ( current ) {
                     sendMessage(characters[index][4].name + " drops " + characters[index][6][holder].name + " and picks up " + stuffs[stuff][1].name);
                     var tmp = stuffs[stuff][1];
                     stuffs[stuff][1] = characters[index][6][holder];
                     characters[index][6][holder] = tmp;
                  } else {
                     sendMessage(characters[index][4].name + " picks up " + stuffs[stuff][1].name);
                     characters[index][6][holder] = stuffs[stuff][1];
                     stuffs[stuff][2].exists = 0;
                  }
               }
            } else {
               // hero can hold multiple from it, and there is no precedence between objects
               if ( characters[index][6][holder] !== undefined && characters[index][6][holder].filter(x=>x===undefined).length ) {
                  for ( var i = 0; i < characters[index][6][holder].length; ++i ) {
                     if ( characters[index][6][holder][i] !== undefined ) {
                        continue;
                     }
                     sendMessage(characters[index][4].name + " picks up " + stuffs[stuff][1].name + " and puts it into slot "+(i+1)+" of "+holder);
                     characters[index][6][holder][i] = stuffs[stuff][1]
                     stuffs[stuff][2].exists = 0;
                     return;
                  }
               }
            }
         }

         function moveCharacter(index) {
            var stuffIndexer = createStuffIndex();
            if ( characters[index][2] != 0
              && Math.abs(characters[index][0][0] - Math.floor(characters[index][0][0]) - 0.5) < errorTolerance
              && Math.abs(characters[index][0][1] - Math.floor(characters[index][0][1]) - 0.5) < errorTolerance ) {
               var stuff = stuffIndexer[getIndexKey(characters[index][0])];
               if ( stuff !== undefined && stuffs[stuff][2].exists ) {
                  pickup(index,stuff);
               }
            }

            if ( characters[index][3].length == 0 ) {
               characters[index][2] = 0;
               return; 
            }
            var characterIndex = createCharacterIndex(); 

            characters[index][2] = ( (characters[index][2]) % 8 + 1 );

            var ctar = characters[index][3][0];
           
            for ( var i = 0; i < 2; ++i ) {
               var targetDistance = Math.abs(ctar[i] + 0.5 - characters[index][0][i]);
               if ( targetDistance > errorTolerance ) {
                  var sgn = Math.sign( ctar[i] + 0.5 - characters[index][0][i] );
                  var incred = [characters[index][0][0],characters[index][0][1]];
                  incred[i] += (0.5/characters[index][4].slowness) * sgn;
                  if ( characterIndex[getIndexKey(incred)] !== undefined && characterIndex[getIndexKey(incred)] !== index ) { // attack
                     attack(index, characterIndex[getIndexKey(incred)]);
                     characters[index][3] = [[Math.floor(characters[index][0][0]),Math.floor(characters[index][0][1])]];
                     return;
                  }
                  characters[index][0] = incred;
                  if ( characters[index][3].length > 1 || targetDistance > 0.5 ) { // not adjusting direction after attack
                     characters[index][1] = 2 * ( sgn < 0 ) + i;
                  }
                  return;
               } else {
                  characters[index][0][i] = ctar[i] + 0.5;
               }
            }

            characters[index][3].reverse();
            characters[index][3].pop();
            characters[index][3].reverse();
         }

         function isCharacterAlive(index) {
            return ( characters[index][6].exists > 1 - errorTolerance );
         }

         function isCharacterFullyDead(index) {
            return ( characters[index][6].exists < errorTolerance );
         }

         function moveCharacters() {
            iterateOverBucketItemsAroundPos(characters[0][0],
                                            characterBuckets,
                                            (i)=>{ isCharacterAlive(i) && (moveCharacter(i) || 1) || isCharacterFullyDead(i) || destroying(i) });
         }

         function giveInstructionsToNPCsWithAI() {
            if ( aiCounter < aiFrequencyDecreaseRatio ) {
               ++aiCounter;
            } else {
               aiCounter = 0;
               var characterIndex = createCharacterIndex();
               iterateOverBucketItemsAroundPos(characters[0][0],
                                               characterBuckets,
                                               (i)=>{ i != 0
                                                   && isCharacterAlive(i)
                                                   && isCharacterAlive(0) 
                                                   && manhattan(characters[0][0], characters[i][0]) <= characters[i][4].range
                                                   && characters[i][3].length == 0
                                                   && (characters[i][3] = bfs({x:Math.floor(characters[i][0][1]),y:Math.floor(characters[i][0][0])},
                                                                              {x:Math.floor(characters[0][0][1]),y:Math.floor(characters[0][0][0])},
                                                                              characterIndex));
                                              });
            }
         }

         // common functions 
         function drawScene() {
            setTimeout( function() {
               ANIMATION = requestAnimationFrame(drawScene);

               var characterIndex = createCharacterIndex();
               drawBackground();
               var visibleTiles = [];
               drawForeground(characters[0][0], characterIndex, visibleTiles);
               drawCursor(curX,curY);
               currentTarget = getCursorsTile(visibleTiles,curX,curY);
               if ( isCharacterAlive(0) && currentTarget !== undefined && getMapCell(currentTarget.y,currentTarget.x) <= floorColors.length ) {
                  var characterIndexOnSelectedCell = characterIndex[getIndexKey([currentTarget.y,currentTarget.x])];
                  drawTile(currentTarget, characterIndexOnSelectedCell === undefined ? "yellow" : (characterIndexOnSelectedCell === 0 ? "blue" : "red"));
               }
               moveCharacters();
               if ( characters[0][6].setUsePotion !== undefined ) {
                  usePotion(characters[0][6].setUsePotion);
                  characters[0][6].setUsePotion = undefined;
               }
               giveInstructionsToNPCsWithAI();
            }, 1000 / fps );
         }

         function initCanvas() {
            screenWidth  = mainItem.width  = window.innerWidth  - 20;
            screenHeight = mainItem.height = window.innerHeight - 20;
            screenScale  = Math.min( screenWidth, screenHeight ) / 2;
            mapRadiusX = screenWidth/4/tileSize/Math.sqrt(3);
            mapRadiusY = screenHeight/4/tileSize;
            mapRadius = Math.ceil(2 * Math.max(mapRadiusX,mapRadiusY));

            // starting the engine only if it is not running
            if ( !ANIMATION ) {
               drawScene();
            }
         }

         mainItem.onmousedown = function(event) {
            if ( currentTarget === undefined ) {
               return;
            }
            var source = {x:Math.floor(characters[0][0][1]),y:Math.floor(characters[0][0][0])};
            if ( source.x === currentTarget.x && source.y === currentTarget.y ) {
               return;
            }
            if ( characters[0][3].length
              && characters[0][3][characters[0][3].length-1][1] == currentTarget.x 
              && characters[0][3][characters[0][3].length-1][0] == currentTarget.y ) {
               return;
            }
            characters[0][3] = bfs(source,currentTarget,createCharacterIndex());
         };

         mainItem.onmouseup = function(event) {};

         mainItem.onmousemove = function(event) { [curX,curY] = [event.clientX,event.clientY]; };

         //init
         (function() {
            initCanvas();
            addEventListener('resize', initCanvas, false);
            addEventListener('keydown', (event)=>{ if ( parseInt(event.key).toString() == event.key ) { characters[0][6].setUsePotion = parseInt(event.key)-1; } });
         })();
      </script>
   </body>
</html>
